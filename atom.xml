<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nich&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nich.work/"/>
  <updated>2019-04-13T16:18:13.576Z</updated>
  <id>https://nich.work/</id>
  
  <author>
    <name>Nich</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Open source apps for Android</title>
    <link href="https://nich.work/2019/Open-source-apps-for-Android/"/>
    <id>https://nich.work/2019/Open-source-apps-for-Android/</id>
    <published>2019-04-06T11:23:14.000Z</published>
    <updated>2019-04-13T16:18:13.576Z</updated>
    
    <content type="html"><![CDATA[<p>与 iOS 编译安装应用也要开发者证书的繁琐比起来，我还是更喜欢 Android 的开放和自由，而开源 APP 就是开放和自由的最好体现。</p><p>以下是一些不错的开源 APP ：</p><a id="more"></a><p>值得注意的是</p><ul><li><strong>开源 APP </strong>并不表示该 APP 没有使用私有、商业的第三方 SDK</li><li><strong>开源 APP</strong> 更需要下载正确的二进制文件以避免第三方篡改 (首选由第三方 <a href="https://f-droid.org/en/" target="_blank" rel="noopener">F-droid</a> 提供的编译，次选 Github release)</li></ul><h3 id="Adaway"><a href="#Adaway" class="headerlink" title="Adaway*"></a><a href="https://github.com/AdAway/AdAway" target="_blank" rel="noopener">Adaway</a>*</h3><p>基于 host 实现的广告拦截工具 (* 需要 root 权限)</p><p>下载地址：<a href="https://f-droid.org/app/org.adaway" target="_blank" rel="noopener">https://f-droid.org/app/org.adaway</a></p><h3 id="Amaze-File-Manager"><a href="#Amaze-File-Manager" class="headerlink" title="Amaze File Manager"></a><a href="https://github.com/TeamAmaze/AmazeFileManager" target="_blank" rel="noopener">Amaze File Manager</a></h3><p>功能齐全的文件管理器</p><p>特色：</p><ul><li>可以管理 root 目录</li><li>支持单页面管理多个 tab </li><li>支持 AES 文件加密/解密</li><li>内置了 Database Reader, Zip/Rar Reader, Apk Reader, Text Reader</li><li>一键将手机存储空间变成局域网 FTP 服务器</li></ul><p>下载地址：<a href="https://f-droid.org/en/packages/com.amaze.filemanager/" target="_blank" rel="noopener">https://f-droid.org/en/packages/com.amaze.filemanager/</a></p><h3 id="AppOpsX"><a href="#AppOpsX" class="headerlink" title="AppOpsX*"></a><a href="https://github.com/8enet/AppOpsX" target="_blank" rel="noopener">AppOpsX</a>*</h3><p><a href="https://www.androidauthority.com/app-ops-need-know-324850/" target="_blank" rel="noopener">appops</a> 的 GUI 权限管理器，在原生系统权限管理之下，能更方便的控制应用权限，避免权限滥用 (* 需要 root 或 adb 授权)</p><p>下载地址：<a href="https://f-droid.org/packages/com.zzzmode.appopsx/" target="_blank" rel="noopener">https://f-droid.org/packages/com.zzzmode.appopsx/</a></p><h3 id="Brave"><a href="#Brave" class="headerlink" title="Brave"></a><a href="https://github.com/brave/browser-android-tabs" target="_blank" rel="noopener">Brave</a></h3><p>在 chromium 基础上添加了广告过滤、隐私管理的开源浏览器，由<a href="https://brave.com/" target="_blank" rel="noopener">营利性公司 Brave </a>维护</p><p>下载地址：<a href="https://github.com/brave/browser-android-tabs/releases" target="_blank" rel="noopener">https://github.com/brave/browser-android-tabs/releases</a></p><h3 id="Bromite"><a href="#Bromite" class="headerlink" title="Bromite"></a><a href="https://github.com/bromite/bromite" target="_blank" rel="noopener">Bromite</a></h3><p>在 chromium 基础上添加了广告过滤、隐私管理并且一定程度上 <a href="https://github.com/bromite/bromite#is-bromite-de-googled" target="_blank" rel="noopener">de-googled</a> 的开源浏览器，由个人维护</p><p>下载地址：<a href="https://github.com/bromite/bromite/releases" target="_blank" rel="noopener">https://github.com/bromite/bromite/releases</a></p><h3 id="DNS66"><a href="#DNS66" class="headerlink" title="DNS66"></a><a href="https://github.com/julian-klode/dns66" target="_blank" rel="noopener">DNS66</a></h3><p>通过全局 VPN 实现的广告拦截工具 </p><p>下载地址：<a href="https://github.com/julian-klode/dns66/releases" target="_blank" rel="noopener">https://github.com/julian-klode/dns66/releases</a></p><h3 id="Fennec-F-Droid"><a href="#Fennec-F-Droid" class="headerlink" title="Fennec F-Droid"></a><a href="https://hg.mozilla.org/" target="_blank" rel="noopener">Fennec F-Droid</a></h3><p>开源版本的 firefox 浏览器</p><p>下载地址：<a href="https://f-droid.org/en/packages/org.mozilla.fennec_fdroid/" target="_blank" rel="noopener">https://f-droid.org/en/packages/org.mozilla.fennec_fdroid/</a></p><h3 id="GeometricWeather"><a href="#GeometricWeather" class="headerlink" title="GeometricWeather*"></a><a href="https://github.com/WangDaYeeeeee/GeometricWeather" target="_blank" rel="noopener">GeometricWeather</a>*</h3><p>设计优美的天气应用 (*使用了 百度定位 、腾讯 Bugly 等第三方追踪 SDK)</p><p>下载地址：<a href="https://github.com/WangDaYeeeeee/GeometricWeather/releases" target="_blank" rel="noopener">https://github.com/WangDaYeeeeee/GeometricWeather/releases</a></p><h3 id="MySplash"><a href="#MySplash" class="headerlink" title="MySplash*"></a><a href="https://github.com/WangDaYeeeeee/Mysplash" target="_blank" rel="noopener">MySplash</a>*</h3><p>轻量化的第三方 Unsplash 客户端 (* 使用了腾讯 Bugly)</p><p>下载地址：<a href="https://f-droid.org/packages/com.wangdaye.mysplash/" target="_blank" rel="noopener">https://f-droid.org/packages/com.wangdaye.mysplash/</a></p><h3 id="OpenPods"><a href="#OpenPods" class="headerlink" title="OpenPods"></a><a href="https://github.com/adolfintel/OpenPods" target="_blank" rel="noopener">OpenPods</a></h3><p>让 Android 也能查看 AirPods 的状态</p><p>下载地址：<a href="https://f-droid.org/packages/com.dosse.airpods/" target="_blank" rel="noopener">https://f-droid.org/packages/com.dosse.airpods/</a></p><h3 id="QKSMS"><a href="#QKSMS" class="headerlink" title="QKSMS"></a><a href="https://github.com/moezbhatti/qksms" target="_blank" rel="noopener">QKSMS</a></h3><blockquote><p>The most beautiful SMS messenger for Android </p></blockquote><p>好看又易用的短信应用</p><p>下载地址：<a href="https://f-droid.org/en/packages/com.moez.QKSMS/" target="_blank" rel="noopener">https://f-droid.org/en/packages/com.moez.QKSMS/</a></p><h3 id="SimpleNote"><a href="#SimpleNote" class="headerlink" title="SimpleNote*"></a><a href="https://github.com/Automattic/simplenote-android" target="_blank" rel="noopener">SimpleNote</a>*</h3><p>由 <a href="https://automattic.com/" target="_blank" rel="noopener">AutoMattic</a> 公司制作并提供服务的跨平台笔记应用 (* 笔记数据将同步至 AutoMattic 服务器)</p><p>下载地址：<a href="https://github.com/Automattic/simplenote-android/releases" target="_blank" rel="noopener">https://github.com/Automattic/simplenote-android/releases</a></p><h3 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a><a href="https://github.com/ccrama/Slide" target="_blank" rel="noopener">Slide</a></h3><p>高效易用的 Reddit 第三方客户端</p><p>下载地址：<a href="https://f-droid.org/app/me.ccrama.redditslide" target="_blank" rel="noopener">https://f-droid.org/app/me.ccrama.redditslide</a></p><h3 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a><a href="https://github.com/termux/termux-app" target="_blank" rel="noopener">Termux</a></h3><p>Android 端的终端应用</p><p>下载地址：<a href="https://f-droid.org/en/packages/com.termux/" target="_blank" rel="noopener">https://f-droid.org/en/packages/com.termux/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 iOS 编译安装应用也要开发者证书的繁琐比起来，我还是更喜欢 Android 的开放和自由，而开源 APP 就是开放和自由的最好体现。&lt;/p&gt;
&lt;p&gt;以下是一些不错的开源 APP ：&lt;/p&gt;
    
    </summary>
    
    
      <category term="App" scheme="https://nich.work/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>使用Gradle插件生成资源ID映射文件</title>
    <link href="https://nich.work/2018/use-gradle-plugin-to-generate-code/"/>
    <id>https://nich.work/2018/use-gradle-plugin-to-generate-code/</id>
    <published>2018-01-10T01:57:47.000Z</published>
    <updated>2019-04-05T09:10:37.130Z</updated>
    
    <content type="html"><![CDATA[<p>因为接入方需要提供 <code>.jar</code> 形式的依赖包进行接入，资源文件要分开提供。即不能通过原生<code>R.xxx</code>的方式获取资源，因为 <code>R.xxx</code> 是最后编译生成，在库内部使用 <code>R.xxx</code> 的值并不能匹配到最后的 编译生成的 id。</p><p>我们在 Android Library 里想要获取资源文件需要通过调用 <code>getResources().getIdentifier(&quot;res_name&quot;, &quot;res_type&quot;, &quot;package_name&quot;)</code> 而不是 APP 层面的 <code>getResoureces().getColor(id)</code> 的形式。</p><p>但这样的代码会导致两个问题：</p><ol><li>需要维护一份”res_name”的列表来与资源文件里的 id 达成映射关系</li><li>由于是硬编码的字符串，在资源文件的 id 有改动时，IDE 并不能发现变化，可能导致映射无效，直到程序崩溃才发现问题</li></ol><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>有网友提供了一个<a href="http://blog.csdn.net/ccpat/article/details/50738811" target="_blank" rel="noopener">方案</a>来解决上面的问题，但是用 Python 脚本手动生成一个映射表的方式并不优雅，除了需要额外的配置外还需手动生成。</p><p>那么有没有一个优雅简洁的方案呢？</p><p>通过参考 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butter Knife</a> 源码，写了一个在 Gradle 编译时自动生成 R2.java 即 id 映射表的 Gradle 插件，与上面网友的方案相比会稍微优雅一点。</p><p>使用方法为</p><ol><li><p>把下面的代码添加至<code>buildscript</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.github.nichbar:r2generator:1.0.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在要应用的 Library 里添加：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'r2generator-plugin'</span></span><br></pre></td></tr></table></figure></li></ol><p>点一下<code>Gradle Sync</code>然后就可以直接使用 R2.xxx 了。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>插件的原理很简单，就是在 Gradle 编译期间对原 Gradle 生成的 R.java 文件进行读取，然后再把读到的 R.java 信息略加修改生成并写到 R2.java 里</p><p>源码及更多细节可见 <a href="https://github.com/nichbar/r2generator" target="_blank" rel="noopener">r2generator</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为接入方需要提供 &lt;code&gt;.jar&lt;/code&gt; 形式的依赖包进行接入，资源文件要分开提供。即不能通过原生&lt;code&gt;R.xxx&lt;/code&gt;的方式获取资源，因为 &lt;code&gt;R.xxx&lt;/code&gt; 是最后编译生成，在库内部使用 &lt;code&gt;R.xxx&lt;/code&gt; 的值并不能匹配到最后的 编译生成的 id。&lt;/p&gt;
&lt;p&gt;我们在 Android Library 里想要获取资源文件需要通过调用 &lt;code&gt;getResources().getIdentifier(&amp;quot;res_name&amp;quot;, &amp;quot;res_type&amp;quot;, &amp;quot;package_name&amp;quot;)&lt;/code&gt; 而不是 APP 层面的 &lt;code&gt;getResoureces().getColor(id)&lt;/code&gt; 的形式。&lt;/p&gt;
&lt;p&gt;但这样的代码会导致两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要维护一份”res_name”的列表来与资源文件里的 id 达成映射关系&lt;/li&gt;
&lt;li&gt;由于是硬编码的字符串，在资源文件的 id 有改动时，IDE 并不能发现变化，可能导致映射无效，直到程序崩溃才发现问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 单元测试</title>
    <link href="https://nich.work/2017/unit-test-of-android/"/>
    <id>https://nich.work/2017/unit-test-of-android/</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2019-04-05T08:25:02.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习 Android 单元测试时的一些笔记。</p><a id="more"></a><h3 id="Android-单元测试"><a href="#Android-单元测试" class="headerlink" title="Android 单元测试"></a>Android 单元测试</h3><p>采用 MVVM 作为 APP 架构的一个好处是在一定程度上分层剥离了 Android 层的代码， 使得基于 JAVA 层的单元测试 (Unit Test) 成为可能。</p><p>下面来介绍一些构建单元测试用到的 Library。</p><h4 id="1-JUnit-4"><a href="#1-JUnit-4" class="headerlink" title="1. JUnit 4"></a>1. JUnit 4</h4><p>单元测试使用的框架是 JUnit 4， JUnit 4 提供了 Java 层的测试基础。</p><p>一个简单的 JUnit 4 示例：</p><p>在 test 目录创建一个 TempTest.java 文件</p><blockquote><p><code>@RunWith</code>注解用于指定使用 JUnit 作为运行框架，<code>@Before</code>标示在测试开始前的操作，<code>@Test</code>标示测试本体。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TempTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mPackage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPackage = <span class="string">"jp.co.nintendo.supermario"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(mPackage.contains(<span class="string">"nintendo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法中的 <code>assertTrue()</code>是JUnit 原生提供的断言方法，于文件中直接右键<code>Run &#39;TempTest&#39;</code>即可运行测试。</p><p>更多 JUnit 的介绍可见 <a href="https://www.jianshu.com/p/e43e56667d9d" target="_blank" rel="noopener">JUnit单元测试框架的使用</a></p><p>更多 JUnit 的使用示例可见 <a href="http://www.vogella.com/tutorials/JUnit/article.html" target="_blank" rel="noopener">Unit Testing with JUnit - Tutorial</a></p><h4 id="2-Mockito"><a href="#2-Mockito" class="headerlink" title="2. Mockito"></a>2. Mockito</h4><p>Mockito 是一个 JAVA 层的 Mocking 框架，通过 Mockito 可以生成一个模拟的桩对象，可供单元测试时替换真实对象以达到两个目的</p><ol><li>验证这个对象的方法的调用情况，如调用次数和参数内容等</li><li>指定这个对象对特定调用方法的行为，如返回的值和额外执行其它操作等</li></ol><p>Mockito 基于 JUnit 4 ，所以类的基本构造与 JUnit 4一样。</p><p>一个简单的 Mockito 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApiService mService;</span><br><span class="line">    <span class="keyword">private</span> UploadRepository mRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 mock(clazz) 方法来模拟一个桩对象作为参数提供给需要被构造的对象</span></span><br><span class="line">        mService = mock(ApiService.class);</span><br><span class="line">        mRepository = <span class="keyword">new</span> UploadRepository(mService);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">  <span class="comment">// 测试上传图片成功后 LiveData 是否发出响应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUploadImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable&lt;String&gt; observable = Observable.just(<span class="string">"Upload Success!"</span>);</span><br><span class="line">        MutableLiveData&lt;String&gt; liveData = mock(MutableLiveData.class);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// mService 是 mock (模拟)出来的空对象，这里设置了当调用 ApiService 的 postUploadImages</span></span><br><span class="line">      <span class="comment">// 方法时直接返回上面生成的 observable    PS: anyObject() 意为接受任何参数</span></span><br><span class="line">        when(mService.postUploadImages(anyObject())).thenReturn(observable);</span><br><span class="line">      </span><br><span class="line">        mRepository.setLiveImageResponse(liveData);</span><br><span class="line">        mRepository.uploadImage(<span class="keyword">new</span> File(<span class="string">"/nintendo/supermario.png"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 校验 liveData 对象是否调用了1次 postValue（） 方法</span></span><br><span class="line">        verify(liveData, times(<span class="number">1</span>)).postValue(anyObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多 Mockito 的介绍可见 <a href="http://www.jianshu.com/p/b6e0cf81641b" target="_blank" rel="noopener">Mock以及Mockito的使用</a></p><p>更多 Mockito 的使用示例可见 <a href="https://static.javadoc.io/org.mockito/mockito-core/2.13.0/org/mockito/Mockito.html#verification" target="_blank" rel="noopener">Mockito examples</a> </p><h4 id="3-Dagger-2"><a href="#3-Dagger-2" class="headerlink" title="3. Dagger 2"></a>3. Dagger 2</h4><p>在实际应用中，使用 Mockito 来模拟对象很快就遇到了问题，当模拟对象不是以参数形式传入被测试对象而是在被测试对象内部自行生成的话，mock 出来的模拟对象就无能为力了，为了继续进行测试可能就需要在测试对象里设置 <code>setXXX()</code>方法来把模拟对象传递进去。</p><p>单独为单元测试而在原逻辑代码里新增<code>setXXX()</code>的方法并不优雅，其实除了创建<code>setXXX()</code>方法这种方式以外，还可以使用 Dagger 2 以注解的形式进行 <a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入(Dependency Injection)</a> 来构造对象。</p><p>使用 Dagger 2 除了代码优雅一点以外，还有以下优点</p><ul><li>减轻了代码维护的压力，修改依赖构造方法的时候只需要修改提供者，请求依赖方不需改动，而不使用 Dagger 2 的话则需要修改每个调用了这个构造方法的类</li><li>可以松开一点数据和逻辑间的耦合</li></ul><p>下面来介绍 Dagger 2 的一些常用的注解 API</p><ul><li><p><code>@Inject</code>： 标记需要被 Dagger2 注入的依赖，常用的有两种注解方式</p><ul><li><p>注解构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivityPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoginActivity loginActivity;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginActivityPresenter</span><span class="params">(LoginActivity loginActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loginActivity = loginActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Inject</code>注解构造器除了能从依赖图里获取参数依赖还能成为依赖图的一部分，即其亦可于在需要的时候被注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>@Inject</code>注解构造器的一个限制是在一个类中只能注解一个构造函数。</p></blockquote></li><li><p>注解变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Inject</code>注解变量这种依赖注入方式需要手动调用注入，要在类中的某个地方执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        getAppComponent().inject(<span class="keyword">this</span>);    <span class="comment">// 请求依赖注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>inject()</code>方法调用前，变量的值均为空。</p><blockquote><p> <em>注意，<code>@Inject</code>注解的变量的修饰符不能为 <code>private</code></em>，原因是 Dagger 2 自动生成的代码需要显式访问该变量(确切地说是为该变量赋值)，与 Butterknife 同理。</p></blockquote></li></ul></li><li><p><code>@Module</code>：用于标记提供依赖的类，Dagger 2 在此寻找依赖</p></li><li><p><code>@Provides</code>： 在含有<code>@Module</code>注解的类中使用，用于标记提供依赖的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiModule</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Provides</span> <span class="comment">// 让 Dagger 2 知道这个方法提供 OkHttpClient 依赖，方法名一般命名为 provideXXX()</span></span><br><span class="line">    <span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Component</code>： 用于构建提供依赖的接口，可以在这里定义需要获得的依赖来自于哪个被<code>@Module</code>修饰的类(或者其它被<code>@Components</code>修饰的类)。<code>@Component</code>可以理解为提供依赖的<code>@Module</code>与待注入依赖的<code>@Inject</code>间的桥梁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;ApiModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Scope</code>：用于自定义依赖单例的生命周期，更多细节可参考<a href="http://blog.csdn.net/mq2553299/article/details/73414710" target="_blank" rel="noopener">Scope注解的使用及源码分析</a></p></li><li><p><code>@Singleton</code>： 用于标记单例，若已存在实例不再生成直接返回</p></li><li><p><code>@Qualifier</code>： 用于区分相同类型的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiRetrofit &#123;&#125;</span><br><span class="line">------- <span class="comment">// Class divider</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserRetrofit &#123;&#125;</span><br><span class="line">------- <span class="comment">// Class divider</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@UserRetrofit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">provideUserRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(<span class="string">"User"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@ApiRetrofit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">provideApiRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Retrofit(<span class="string">"Api"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiService <span class="title">provideApiService</span><span class="params">(@ApiRetrofit Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(ApiService.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">provideUserService</span><span class="params">(@UserRetrofit Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(UserService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>简单介绍了常用 API ，接下来演示简单的用法</p><p>首先是提供依赖类 <code>@Module</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiModule</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">LoginActivityPresenter <span class="title">provideLoginPresenter</span><span class="params">(OkhttpClient client)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoginActivityPresenter(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是桥梁 <code>@Component</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;ApiModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是需要被注入依赖的 <code>LoginActivity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">      <span class="comment">// DaggerApiComponent 是由 Dagger2 实现 ApiComponent 接口自动生成的类</span></span><br><span class="line">        DaggerApiComponent.builder()</span><br><span class="line">                .build()</span><br><span class="line">                .inject(<span class="keyword">this</span>);</span><br><span class="line">      </span><br><span class="line">      presenter.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 presenter 对象就由 Dagger 2 实现了注入，可供使用。</p><p>更多相关的 Dagger 2 使用技巧可见 <a href="https://github.com/xitu/gold-miner/blob/master/TODO/Dependency-Injection-with-Dagger-2.md" target="_blank" rel="noopener">用 Dagger 2 实现依赖注入</a></p><p>虽然 Dagger 2 自动生成代码完成依赖注入很棒，但因为 <code>Activity</code>和<code>Fragment</code>等控件是由安卓系统生成，导致许多成员注入都写在它们的生命周期回调里，许多类最后会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrombulationActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> Frombulator frombulator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// DO THIS FIRST. Otherwise frombulator might be null!</span></span><br><span class="line">        ((SomeApplicationBaseType) getContext().getApplicationContext())</span><br><span class="line">            .getApplicationComponent()</span><br><span class="line">            .newActivityComponentBuilder()</span><br><span class="line">            .activity(<span class="keyword">this</span>)</span><br><span class="line">            .build()</span><br><span class="line">            .inject(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// ... now you can write the exciting code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断地重复这样的代码会导致这样的问题：</p><ol><li>不利于重构，拷来拷去，可能到最后会忘了这段代码的实际用途</li><li>往更深一层去看，这些代码显式地去指明了它的注入者，即便指明的是接口但也违背了依赖注入时类本身不知道注入方式的基本原则</li></ol><p>这时候应用 <a href="https://google.github.io/dagger//android.html" target="_blank" rel="noopener">dagger.android</a> 库就可以使代码更优雅。</p><p>下面来介绍一下 dagger.android 这个库的简单使用方式</p><ol><li><p>在 Application 级的 Component 里添加 AndroidInjectionModule</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;AndroidInjectionModule.class, AppModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// For brevity.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为需要注入依赖的 Activity 书写继承了 AndroidInjector\<youractivity> 的接口，并带有继承了AndroidInjector\<youractivity> 一个抽象的 Builder类</youractivity></youractivity></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subcomponent 可以理解为子 Component，在拥有自己的 Mod概念概念ule 的同时亦可以使用父 Component 的</span></span><br><span class="line"><span class="comment">// Module，不同 Subcomponent 之间的 Module 不能直接互用 （类似于命名空间的概念）</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = ...)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">YourActivitySubcomponent</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>&lt;<span class="title">YourActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>.<span class="title">Builder</span>&lt;<span class="title">YourActivity</span>&gt; </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化简化定义了上述 SubComponent 以后再写一个 Module 来绑定它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span>(subcomponents = YourActivitySubcomponent.class)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@ActivityKey</span>(YourActivity.class)</span><br><span class="line">    <span class="keyword">abstract</span> AndroidInjector.Factory&lt;? extends Activity&gt;</span><br><span class="line">        bindYourActivityInjectorFactory(YourActivitySubcomponent.Builder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 Application 级的 Component 里将 Module 添加进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;AndroidInjectionModule.class,, YourActivityModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"><span class="comment">// For brevity.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 SubComponent 及其 Builder 没有其它方法或者是超类的话，可以用 @ContributesAndroidInjector 注解来替换掉上面的步骤2和步骤3 ，具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span>(modules = &#123; <span class="comment">/* modules to install into the subcomponent */</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> YourActivity <span class="title">contributeYourActivityInjector</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其添加至 Application 级的 Component 即可</p></li><li><p>Application 实现 HasActivityInjector 接口以及 <code>@Inject</code>注入一个 DispatchingAndroidInjector\<activity> 供 <code>activityInjector()</code> 作为返回值</activity></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">HasActivityInjector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate();</span><br><span class="line">      DaggerAppComponent.create()</span><br><span class="line">          .inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AndroidInjector&lt;Activity&gt; <span class="title">activityInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatchingActivityInjector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后在 Activity 调用 <code>super.onCreate()</code>前调用<code>AndroidInjector.inject()</code>即可完成依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    AndroidInjection.inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上述是注入依赖到 Activity 的流程，注入依赖到 Fragment 中的方式也类似，具体差异可参考官方文档 <a href="https://google.github.io/dagger//android.html#Injecting%20Fragment%20objects" target="_blank" rel="noopener">Injecting Fragment objects</a></p><p>通过查看 Dagger 自动生成的 <code>DaggerAppComponent.java</code>文件不难发现， dagger.android 库通过分析提供的注解把提供依赖的 Module 添加到 Map 里，当在需要注入的控件调用 <code>AndroidInjection.inject(this)</code>其逻辑就是从该 Map 或其子 Map 里去取控件相对应的 Module 来实现依赖注入。</p><p>参照 <a href="https://github.com/googlesamples/android-architecture-components/blob/178fe541643adb122d2a8925cf61a21950a4611c/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppInjector.java#L41" target="_blank" rel="noopener">Google Archtitecture Sample</a> 通过使用<code>registerActivityLifecycleCallbacks()</code>以及<code>registerFragmentLifecycleCallbacks()</code>在控件相应的生命周期回调里调用 <code>AndroidInjection.inject()</code>方法的话，代码能达到进一步的简化。</p><h4 id="4-Espresso"><a href="#4-Espresso" class="headerlink" title="4. Espresso"></a>4. Espresso</h4><p>Google 官方将 APP 测试分为三种，小型、中型和大型测试，其分配的比例分为70% 、20%和10%。</p><p>上面介绍的单元测试就是占比最大的 70% 测试，而 Espresso 则是构成 20% 和 10% 所使用的库。</p><p>与Mockito 不一样 Espresso 是一个 UI 测试框架，运行时需要用到 Android 的代码，所以需要编译运行，时间会长很多。</p><p>下面是一个简单的 Espresso 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class) <span class="comment">// 与JUnit 4的内容略有不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadDetailFragmentTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span> <span class="comment">// 使用一个空的Activity来承载Fragment</span></span><br><span class="line">    <span class="keyword">public</span> ActivityTestRule&lt;SingleFragmentActivity&gt; mActivityRule =</span><br><span class="line">            <span class="keyword">new</span> ActivityTestRule&lt;&gt;(SingleFragmentActivity.class, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UploadViewModel mViewModel;</span><br><span class="line">    <span class="keyword">private</span> ApiService mApiService;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData mMutableLiveData = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UploadDetailFragment fragment = <span class="keyword">new</span> UploadDetailFragment();</span><br><span class="line"></span><br><span class="line">        mViewModel = mock(UploadViewModel.class);</span><br><span class="line">        mApiService = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(Config.API_HOST)</span><br><span class="line">                .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build().create(ApiService.class);</span><br><span class="line">      </span><br><span class="line">        when(mViewModel.getLiveData()).thenReturn(mMutableLiveData);</span><br><span class="line"></span><br><span class="line">        fragment.setMApiService(mApiService);</span><br><span class="line">        fragment.setMFactory(<span class="keyword">new</span> ViewModelProviderFactory&lt;&gt;(mViewModel));</span><br><span class="line"></span><br><span class="line">        mActivityRule.getActivity().setFragment(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试图片上传成功与失败的文字显示状态</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadCover</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 检测view是否处于显示状态</span></span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .perform(ViewActions.scrollTo())</span><br><span class="line">                .check(matches(isDisplayed()));</span><br><span class="line"></span><br><span class="line">        UploadObservableDataWrapper successWrapper = <span class="keyword">new</span> UploadObservableDataWrapper();</span><br><span class="line">        successWrapper.isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        successWrapper.dataType = DataType.APP_COVER_URL;</span><br><span class="line">        successWrapper.url = <span class="string">"https://pic.google.com/"</span>;</span><br><span class="line">        mMutableLiveData.postValue(successWrapper);</span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .check(matches(not(isDisplayed())));</span><br><span class="line"></span><br><span class="line">        UploadObservableDataWrapper failedWrapper = <span class="keyword">new</span> UploadObservableDataWrapper();</span><br><span class="line">        failedWrapper.isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        failedWrapper.dataType = DataType.APP_COVER_URL;</span><br><span class="line">        failedWrapper.url = <span class="string">"https://pic.google.com/"</span>;</span><br><span class="line">        mMutableLiveData.postValue(failedWrapper);</span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .check(matches(isDisplayed()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多 Espresso 的介绍可见 <a href="http://www.jianshu.com/p/c5da84eae63b" target="_blank" rel="noopener">UI测试(Espresso)</a></p><p>更多 Espresso 的使用示例可见 <a href="http://www.vogella.com/tutorials/AndroidTestingEspresso/article.html" target="_blank" rel="noopener">Espresso Tutorial</a> </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>上文所有可跳转链接以及下列文章</p><ul><li><a href="https://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/" target="_blank" rel="noopener">Dependency injection with Dagger 2</a></li><li><a href="https://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/" target="_blank" rel="noopener">DaggerAndroid原理解析</a></li><li><a href="https://google.github.io/dagger/users-guide" target="_blank" rel="noopener">Dagger 2 Users Guide</a></li><li><a href="https://developer.android.com/topic/libraries/testing-support-library/index.html" target="_blank" rel="noopener">测试支持库</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习 Android 单元测试时的一些笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="https://nich.work/2017/TCP/"/>
    <id>https://nich.work/2017/TCP/</id>
    <published>2017-10-09T10:40:03.000Z</published>
    <updated>2017-10-09T10:41:20.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习 TCP (Transmission Control Protocol) 的一些笔记。</p><a id="more"></a><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p>The <strong>Transmission Control Protocol</strong> (<strong>TCP</strong>) is one of the main <a href="https://en.wikipedia.org/wiki/Communications_protocol" target="_blank" rel="noopener">protocols</a> of the <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">Internet protocol suite</a>. It originated in the initial network implementation in which it complemented the <a href="https://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener">Internet Protocol</a> (IP). Therefore, the entire suite is commonly referred to as <a href="https://en.wikipedia.org/wiki/TCP/IP" target="_blank" rel="noopener">TCP/IP</a>. </p><p>TCP provides <a href="https://en.wikipedia.org/wiki/Reliability_(computer_networking" target="_blank" rel="noopener">reliable</a>), ordered, and <a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="noopener">error-checked</a> delivery of a stream of <a href="https://en.wikipedia.org/wiki/Octet_(computing" target="_blank" rel="noopener">octets</a>) between applications running on hosts communicating by an IP network. Major Internet applications such as the <a href="https://en.wikipedia.org/wiki/World_Wide_Web" target="_blank" rel="noopener">World Wide Web</a>, <a href="https://en.wikipedia.org/wiki/Email" target="_blank" rel="noopener">email</a>, <a href="https://en.wikipedia.org/wiki/Remote_administration" target="_blank" rel="noopener">remote administration</a>, and <a href="https://en.wikipedia.org/wiki/File_transfer" target="_blank" rel="noopener">file transfer</a> rely on TCP. Applications that do not require reliable data stream service may use the <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener">User Datagram Protocol</a> (UDP), which provides a <a href="https://en.wikipedia.org/wiki/Connectionless_communication" target="_blank" rel="noopener">connectionless</a> <a href="https://en.wikipedia.org/wiki/Datagram" target="_blank" rel="noopener">datagram</a> service that emphasizes reduced <a href="https://en.wikipedia.org/wiki/Latency_(engineering" target="_blank" rel="noopener">latency</a>) over reliability.</p></blockquote><h3 id="2-TCP-IP"><a href="#2-TCP-IP" class="headerlink" title="2. TCP/IP"></a>2. TCP/IP</h3><p>TCP 作为 TCP/IP 的关键协议为人所熟知，在这里对 TCP/IP 进行简单描述 。</p><p>TCP/IP 协议族分为四层：</p><p><img src="https://i.loli.net/2017/09/28/59ccf3e410e38.png" width="250"></p><h5 id="2-1-链路层"><a href="#2-1-链路层" class="headerlink" title="2.1 链路层"></a>2.1 链路层</h5><p>链路层位于 TCP/IP 协议族的最底层，链路层主要有三个目的：（1）为 IP 模块发送和接收 IP 数据报；（2）为 <a href="https://zh.wikipedia.org/zh-hans/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">ARP</a> (Address Resolution Protocol  地址解析协议) 模块发送 ARP 请求和接收ARP应答；（3）为 <a href="https://zh.wikipedia.org/zh-hans/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">RARP</a> (Reverse Address Resolution Protocol 逆地址解析协议) 发送 RARP 请求和接收 RARP 应答。</p><h5 id="2-2-网络层"><a href="#2-2-网络层" class="headerlink" title="2.2 网络层"></a>2.2 网络层</h5><p>网络层提供<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">路由</a>和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。由于TCP/IP协议族中的网络层功能由 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">IP 协议</a>规定和实现，故又称 IP 层。</p><h5 id="2-3-传输层"><a href="#2-3-传输层" class="headerlink" title="2.3 传输层"></a>2.3 传输层</h5><p>传输层的协议为应用层提供端到端的通信服务，其中最著名的传输层协议就是下面即将详细分析的传输控制协议 (TCP) 以及 用户数据报协议 (UDP)。</p><h5 id="2-4-应用层"><a href="#2-4-应用层" class="headerlink" title="2.4 应用层"></a>2.4 应用层</h5><p>应用层直接和应用程序接口并提供常见的网络应用服务。</p><p>可以用一张图来作为一个 TCP/IP 数据包结构的示例：</p><p><img src="https://i.loli.net/2017/09/28/59cd0093f131a.png" width="450"></p><h3 id="3-TCP-包结构"><a href="#3-TCP-包结构" class="headerlink" title="3. TCP 包结构"></a>3. TCP 包结构</h3><p>TCP 接收来自数据流的数据，将其分成块，并为其添加 TCP 头部使其成为 TCP 数据包。TCP 数据包稍后会被包裹成 IP 数据包与另一端进行数据交换。</p><p>TCP/IP 对每一层的数据包都用不同的英文专业术语来描述，在 Transport Layer 里的 TCP 数据包被称为 Segment、UDP 数据包被称为 UDP Datagram，在 Internet Layer 被称为 IP Datagram，在 Link Layer 被称为 Frame。当然有时亦会被泛称为”Packet”，但中文一般都以一个更泛用的”包”来形容。</p><p>一个 TCP 数据包由头部和数据两部分构成。</p><ul><li>头部由十个必须域以及一个可选域构成</li><li>数据部分位于头部后面，其内容即为负载的应用层数据。数据部分的长度虽未于头部中描述，但可通过 IP 数据包的长度(Total Length)减去 IP 数据包头部以及 TCP 数据包头部获得</li></ul><h5 id="3-1-一些概念"><a href="#3-1-一些概念" class="headerlink" title="3.1 一些概念"></a>3.1 一些概念</h5><ul><li>MTU (Maximum Transmission Unit)：是网络层能单次负载的最大单元，网络层协议会根据这个值来决定是否把上层传下来的数据进行分片。</li><li>MSS (Maximum Segment Size)：TCP 数据包所能负载的最大体积，单位为字节，出于性能考虑，MSS 应该设得比 MTU 小，以避免 IP 分片</li><li>WS (Window Scaling)：滑动窗口，用于提高带宽的利用效率(占位，细节待补充)</li><li>SACK (Selective Acknowledgments)：接收端用于确认接收到的不连续块是否正确(占位，细节待补充)</li></ul><h5 id="3-2-TCP-头部信息"><a href="#3-2-TCP-头部信息" class="headerlink" title="3.2 TCP 头部信息"></a>3.2 TCP 头部信息</h5><p>TCP 头部信息，如下图</p><p><img src="https://i.loli.net/2017/10/01/59d054b926d09.png" alt="TCP Header.png"></p><ul><li>Source port 源端口和 Destination port 目的端口：用于寻找发送端和接收端应用程序，这两个值加上 IP 头部中的发送端 IP 地址和接收端 IP 地址唯一确定一个 TCP 连接</li></ul><blockquote><p>应用程序的端口号和应用程序所在主机的IP地址统称为 socket (套接字)，IP:XX, 在互联网上 socket 唯一标识每一个应用程序，源端口+源 IP +目的端口+目的 IP 称为套接字对，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p></blockquote><ul><li><p>Sequence Number 序号：占32 bit，有两种不同的作用</p><ul><li>如果 SYN 标记位的值为1 ，那么当前序号就是初始序号(Initial Sequence Number)，是接收到的顺序排第一的数据包，回应的确认序号将在此序号上加1</li><li>如果 SYN 标记位的值为0，那么当前序号就是当前数据通信会话中从初始序号开始累增的序号</li></ul></li><li><p>Acknowledgment Number 确认序号：占32 bit，如果 ACK 标记位的值为1，那么当前确认序号的值就是发送方所期待的序号。确认先前收到的所有字节，每个端发送的第一个确认序号确定另一端的初始序号</p></li><li><p>Data offset 数据偏移：占4 bit，最大可表示 15 <em> 32 bit / 8 = 60 字节，最小为5 </em> 32 bit / 8 = 20 字节，提供了最大为40 字节的 options 部分。数据偏移确定了 TCP 数据部分在 TCP 数据包里的偏移（开始）位置</p></li><li><p>Preserved 保留：占3 bit ，均为0</p></li><li><p>Flag 标记位 (又叫控制位)占9 bit</p><ul><li>NS、CWR、ECE：不懂(占位，细节待补充)</li><li>URG：标示 Urgent pointer 紧急指针是重要的</li><li>ACK：标示确认序号 Acknowledgment Number 是重要的。在初始化 SYN 数据包之后发送的数据包都应该将此标记位设为 1</li><li>PSH：发送方使用该标志通知接收方将所有缓冲的数据提交给应用程序</li><li>RST：重置连接</li><li>SYN：同步序号，只有双方发的第一个包应该将此标记位设为 1.</li><li>FIN：标示发送方的最后一个数据包</li></ul></li><li><p>Window Size 窗口大小：占16 bit，通过告诉对方本端 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就能按需控制发送数据的速度</p></li><li><p>Checksum 校验和：占16 bit，用于校验，确保报文的准确性和完整性</p></li><li><p>Urgent pointer 紧急指针：占16 bit，如果设置了 URG 标记位，那么这个16 bit 的域就是紧急数据相对序号 Sequence Number 的偏移量</p></li><li><p>Options 选项：Options 的长度是由 Data Offset (数据偏移)决定的 (最多40字节)。Options 有三个域，分别是 Option-Kind  (1字节)， Option-Length (1字节)以及 Option-Data (可变长度)，下面是一些 Option-Kind</p><ul><li>0：选项表结束</li><li>1：无操作 (NOP – No Operation)，用来对齐边界提高性能</li><li>2：MSS</li><li>3：WS</li><li>4：发送端支持并同意使用 SACK</li><li>5：具体的 SACK</li><li>8：时间戳 (占位，细节待补充)</li></ul></li><li><p>Padding ：头部填充，用于确保 TCP 头部结束，令数据在32 bit 的边界上开始</p><p>下面用 Wireshark 抓到的包和上面说到首部信息进行示例展示</p><p><img src="https://ooo.0o0.ooo/2017/09/29/59cdb60565a13.png" alt="sample.png"></p></li></ul><h3 id="4-TCP-连接的建立"><a href="#4-TCP-连接的建立" class="headerlink" title="4. TCP 连接的建立"></a>4. TCP 连接的建立</h3><p>TCP 采用了三次握手的方式来创建一个连接。在客户端尝试主动与服务端建立连接前，服务端必须先被动地监听将要建立连接的端口。以下是三次握手的细节：</p><ol><li>SYN：客户端主动地发送带有SYN 标记位的数据包给服务器，数据包的序号被设为一个随机数值 A</li><li>SYN-ACK：服务端回复 SYN-ACK 作为回应，确定序号设置为接收到的数据包的序号加一，即 A+1 ，这时服务端将把数据包的序号设置为另一个随机数值 B</li><li>ACK：最后，客户端发送 ACK 至服务端，序号设置为接收的数据包的确定序号，即 A+1，确认序号设置为接收的数据包的确定序号加一，即 B+1</li></ol><p>完成三次握手后，客户端和服务端都确定了连接的建立。</p><p>可以用一张 GIF 图来表示握手：</p><p><img src="https://i.loli.net/2017/10/01/59d0fc30e3726.gif" width="650"></p><h3 id="5-TCP-数据的传输"><a href="#5-TCP-数据的传输" class="headerlink" title="5. TCP 数据的传输"></a>5. TCP 数据的传输</h3><p>客户端和服务端完成握手建立连接以后，双方便可以进行全双工(full-duplex)的通信。</p><p>TCP 使用序号 (Sequence Number) 来标识数据，数据传输的两端能通过序号重排列传输的数据。</p><p>数据传输的一个示例如下图：</p><p><img src="https://i.loli.net/2017/10/09/59db44ba2b03b.png" alt="6.png"></p><p>当服务端朝客户端传递数据时，客户端会回应设置了 ACK 标记位的数据包，告诉服务端自己收到了相应段的数据。</p><p>(占位，传输策略的细节待补充)</p><h3 id="6-TCP-连接的断开"><a href="#6-TCP-连接的断开" class="headerlink" title="6. TCP 连接的断开"></a>6. TCP 连接的断开</h3><p>TCP 使用了4次握手(four-way handshake) 来断开连接，确保了两端都能独立地断开连接。</p><p>当一端 I 想要断开连接，该端会发送设置了 FIN 标记位的数据包给另一端 R ，另一端 R 会返回一个设置了 ACK 标记位的数据包。所以一次典型的连接断开需要每个终端都提供一对带 FIN 和 ACK 标记的数据包，如下图：</p><p><img src="https://ooo.0o0.ooo/2017/10/09/59db506c3da32.png" alt="375px-TCP_CLOSE.svg.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol – Wikipedia</a></li><li><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解 卷1：协议</a></li><li><a href="https://stackoverflow.com/questions/11636405/definition-of-network-units-fragment-segment-packet-frame-datagram" target="_blank" rel="noopener">Definition of Network Units: Fragment, Segment, Packet, Frame, Datagram</a></li><li><a href="https://my.oschina.net/hding/blog/678841" target="_blank" rel="noopener">重读TCP/IP(5)之TCP头部</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习 TCP (Transmission Control Protocol) 的一些笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Magic" scheme="https://nich.work/tags/Magic/"/>
    
  </entry>
  
  <entry>
    <title>几种常见的排序算法</title>
    <link href="https://nich.work/2017/basicSortingAlgorithm/"/>
    <id>https://nich.work/2017/basicSortingAlgorithm/</id>
    <published>2017-09-21T15:50:27.000Z</published>
    <updated>2017-09-22T17:09:42.815Z</updated>
    
    <content type="html"><![CDATA[<p>整理复习了一下几种常见的排序算法，参考资料为<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a>。简单分析了它们的基本原理，没有涉及到复杂度的计算，仅仅以结果的形式记录，在每种排序算法的最后都提供了 JavaScript 的实现代码。</p><a id="more"></a><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h3><p>重复地走访要排序的序列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访序列的工作是重复地进行直到不再需要交换，序列排序完成。</p><p><img src="https://i.loli.net/2017/09/22/59c47cb45d6f8.gif" alt="Bubble Sort"></p><p>时间复杂度为O(n^2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">this</span>[j + <span class="number">1</span>] = <span class="keyword">this</span>[j];</span><br><span class="line">                <span class="keyword">this</span>[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-插入排序-Insertion-Sort"><a href="#2-插入排序-Insertion-Sort" class="headerlink" title="2. 插入排序 (Insertion Sort)"></a>2. 插入排序 (Insertion Sort)</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。</p><p>具体细节如图：</p><p><img src="https://i.loli.net/2017/09/22/59c4c62c3831e.gif" alt="Insertion Sort"></p><p>时间复杂度为O(n^2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            temp = <span class="keyword">this</span>[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">this</span>[j - <span class="number">1</span>] = <span class="keyword">this</span>[j];</span><br><span class="line">            <span class="keyword">this</span>[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序-Selection-Sort"><a href="#3-选择排序-Selection-Sort" class="headerlink" title="3. 选择排序 (Selection Sort)"></a>3. 选择排序 (Selection Sort)</h3><p>首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，放到已排序序列的末尾，循环此过程，直到所有元素排列完毕。</p><p>具体细节如图：</p><p><img src="https://i.loli.net/2017/09/22/59c4c7b9d3524.gif" alt="Selection-Sort-Animation.gif"></p><p>时间复杂度为O(n^2)。</p><p>交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, min;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = <span class="keyword">this</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="keyword">this</span>.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &lt; min) &#123;</span><br><span class="line">                min = <span class="keyword">this</span>[j];</span><br><span class="line">                <span class="keyword">this</span>[j] = <span class="keyword">this</span>[i];</span><br><span class="line">                <span class="keyword">this</span>[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序-Quick-Sort"><a href="#4-快速排序-Quick-Sort" class="headerlink" title="4. 快速排序(Quick Sort)"></a>4. 快速排序(Quick Sort)</h3><p>快速排序使用分治法，把一个序列分为两个子序列来排序。</p><p>步骤可分为：</p><ol><li>从序列中挑出一个元素作为基准(pivot)</li><li>重新排序序列，所有比基准值小的元素摆放在基准前面，比基准大的元素摆在基准后面</li><li>递归地把小于基准值元素的子序列和大于基准值元素的子数列排序</li></ol><p><img src="https://i.loli.net/2017/09/22/59c47e6bc3dd5.gif" alt="Quick Sort"></p><p>最优时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)</p><p>基础版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">var</span> mid = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[i] &lt; mid[<span class="number">0</span>]) &#123;</span><br><span class="line">        left.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left.quickSort().concat(mid.concat(right.quickSort()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>一样不好。额外需要的<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">内存</a>空间配置，在实际上的实现，也会极度影响速度和<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96" target="_blank" rel="noopener">缓存</a>的性能。有一个比较复杂使用<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a>（in-place）分区<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a>的版本，且在好的基准选择上，平均可以达到O(log <em>n</em>)空间的使用复杂度。(<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>)</p></blockquote><p>原地 (In-place) 版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.quickSortIP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = array[i];</span><br><span class="line">        array[i] = array[k];</span><br><span class="line">        array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> storeIndex = left;</span><br><span class="line">        <span class="keyword">var</span> pivot = array[right]; <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">                swap(array, i, storeIndex);</span><br><span class="line">                storeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(array, right, storeIndex); <span class="comment">// 将基准还原到正确位置</span></span><br><span class="line">        <span class="keyword">return</span> storeIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> storeIndex = partition(array, left, right);</span><br><span class="line">        sort(array, left, storeIndex - <span class="number">1</span>);</span><br><span class="line">        sort(array, storeIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-希尔排序-Shell-Sort"><a href="#5-希尔排序-Shell-Sort" class="headerlink" title="5. 希尔排序 (Shell Sort)"></a>5. 希尔排序 (Shell Sort)</h3><p>希尔排序是插入排序一种更高效的改进版本，基于以下插入排序的两种特点进行改进：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率</li><li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>算法思路：</p><ol><li>先取一个正整数 d1 (d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 倍数的记录看成一组，然后在各组内进行插入排序</li><li>取正整数 d2 (d2 &lt; d1)</li><li>重复上述操作，直到 di = 1 (i &gt;= 1)，即所有记录成为一个组，最后对这个组进行插入排序即可</li></ol><p>最优时间复杂度为O(<em>n</em> log2 <em>n</em>)，最坏时间复杂度为O(n^2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处 d1 选取了 n/2</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = array[i];</span><br><span class="line">        array[i] = array[k];</span><br><span class="line">        array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt; <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>[j - gap] &gt; <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                    swap(<span class="keyword">this</span>, j - gap, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理复习了一下几种常见的排序算法，参考资料为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;。简单分析了它们的基本原理，没有涉及到复杂度的计算，仅仅以结果的形式记录，在每种排序算法的最后都提供了 JavaScript 的实现代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://nich.work/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>分析 DiskLruCache</title>
    <link href="https://nich.work/2017/DiskLruCache/"/>
    <id>https://nich.work/2017/DiskLruCache/</id>
    <published>2017-09-11T15:17:00.000Z</published>
    <updated>2017-09-11T15:45:05.149Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试去简单分析来自 <a href="https://github.com/JakeWharton" target="_blank" rel="noopener">Jake Wharton</a> 大神的 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a> 库，尽管这个库已经有多年历史，但至今仍然被 <a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>、<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a> 等主流基础库用以作为磁盘缓存的基础，仍有不错的学习价值。</p><a id="more"></a><p>在分析 DiskLruCache 之前，先对 Android SDK 里附带的 <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/util/LruCache.java" target="_blank" rel="noopener">LruCache</a> 进行简单介绍。(基于Android SDK 25)</p><h3 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h3><p>LRU (Least Recently Used)，从名字就不难看出 LruCache 使用的缓存策略 — 缓存满了的时候，先抛弃近期最少使用的缓存对象。</p><blockquote><p>This class appeared in Android 3.1; it’s available as part of <a href="http://developer.android.com/sdk/compatibility-library.html" target="_blank" rel="noopener">Android’s Support Package</a> for earlier releases.</p></blockquote><p>LruCache 从 Android 3.1 开始提供，所以在2017年的今天可以直接用来实现内存缓存。</p><h5 id="LruCache-原理"><a href="#LruCache-原理" class="headerlink" title="LruCache 原理"></a>LruCache 原理</h5><p>LruCache 的实现原理并不难理解，LruCache 用了 LinkedHashMap 来存缓存，巧妙地使用了 LinkedHashMap 在数据被访问时将被访问的数据放至链表最后(即头部前面)的特性，在需要删除缓存时将 LinkedHashMap 链表从前面(即头部后面)开始移出集合。</p><h5 id="LruCache-需要注意的几点"><a href="#LruCache-需要注意的几点" class="headerlink" title="LruCache 需要注意的几点"></a>LruCache 需要注意的几点</h5><ol><li>LruCache 默认的 <code>sizeOf()</code> 方法返回的是 1，如果要以缓存大小而不是缓存数目来控制需要重载 <code>sizeOf()</code>方法。</li><li>若要特定释放缓存的资源，需要重载 <code>entryRemoved()</code> 方法。</li><li>不允许空 key 或空 value。</li></ol><h3 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h3><p>回到 DiskLruCache ，因为 IO 操作的效率远不如内存操作，所以 DiskLruCache 一般是三级缓存策略里优先级最低的存在。虽然优先级低，但是重要性并不低。</p><h5 id="DiskLruCache-原理"><a href="#DiskLruCache-原理" class="headerlink" title="DiskLruCache 原理"></a>DiskLruCache 原理</h5><p>DiskLruCache 的核心原理跟 LruCache 基本一致，一样是利用了 LinkedHashMap 的特性来实现 LRU 策略。</p><h5 id="DiskLruCache-的内部类"><a href="#DiskLruCache-的内部类" class="headerlink" title="DiskLruCache 的内部类"></a>DiskLruCache 的内部类</h5><p>DiskLruCache 有三个内部类，分别为 <code>Entry</code>、<code>Snapshot</code> 和 <code>Editor</code>。</p><ol><li><p>Entry</p><p><code>Entry</code>是 DiskLruCache 内 LinkedHashMap Value 的基本结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    <span class="keyword">long</span>[] lengths;</span><br><span class="line">    <span class="keyword">boolean</span> readable;</span><br><span class="line">    Editor currentEditor;</span><br><span class="line">    <span class="keyword">long</span> sequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>key</code>是 <code>Entry</code>的唯一标识</p></li><li><p><code>lengths</code>是与<code>key</code>匹配的缓存的大小，数组长度与创建 <code>DiskLruCache</code>时入参 <code>valueCount</code>的值一致</p></li><li><p><code>readable</code>是当前缓存是否已经被创建至磁盘的标记</p></li><li><p><code>currentEditor</code>是一个 <code>Editor</code>对象，在当前处于被编辑状态中的<code>Entry</code>里不为空</p></li><li><p><code>sequenceNumber</code>记录了最近一次<code>Entry</code>的更新，每次更新<code>Entry</code>均会递增，用于判断 <code>Snapshot</code>是否过期</p></li></ul></li><li><p>Snapshot</p><p><code>Snapshot</code>是<code>Entry</code>的快照(snapshot)。当调用 <code>diskLruCache.get(key)</code>时，便能获得一个<code>Snapshot</code>对象，该对象可用于获取或更新存于磁盘的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    <span class="keyword">long</span> sequenceNumber;</span><br><span class="line">    InputStream[] ins;</span><br><span class="line">    <span class="keyword">long</span>[] lengths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>key</code>即用于获取相应<code>Entry</code>快照的 key</li><li><code>sequenceNumber</code>可以理解为当前<code>Snapshot</code>对象的版本号，当与目标<code>Entry</code>的<code>sequenceNumber</code>不一致时，当前<code>Snapshot</code>失效，不能用于更新存于磁盘的缓存</li><li><code>ins</code>是一个<code>InputStream</code>的数组，其大小与创建 <code>DiskLruCache</code>时入参 <code>valueCount</code>的值一致，是供获取磁盘缓存的输入流</li><li><code>lenghts</code>与<code>Entry</code>里的<code>lengths</code>一样是与<code>key</code>匹配的缓存的大小</li></ul></li><li><p>Editor</p><p>每个<code>Entry</code>都包裹有一个<code>Editor</code>对象，当<code>Entry</code>对象处于被编辑状态时不为空。所以<code>Editor</code>能有效避免多个编辑动作同时应用于<code>Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    Entry entry;</span><br><span class="line">    <span class="keyword">boolean</span>[] written;</span><br><span class="line">    <span class="keyword">boolean</span> hasErrors;</span><br><span class="line">    <span class="keyword">boolean</span> committed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>entry</code>本<code>Editor</code>的编辑对象</li><li><code>written</code>用于标记当前<code>Editor</code>对象里的<code>entry</code>是否已被写入至磁盘中</li><li><code>hasErrors</code>用于标记执行输出流时是否有错误</li><li><code>committed</code>标记<code>Editor</code>对象是否调用过<code>editor.commit()</code>方法</li></ul></li></ol><h5 id="Journal-文件"><a href="#Journal-文件" class="headerlink" title="Journal 文件"></a>Journal 文件</h5><p>DiskLruCache 通过在磁盘中创建并维护一个简单的<code>Journal</code>文件来记录各种缓存操作，供初始化时生成 LinkedHashMap 用。记录的类型有4种，分别为<code>READ</code>、<code>REMOVE</code>、<code>CLEAN</code>和<code>DIRTY</code>。</p><ul><li><code>READ key</code>— 是<code>key</code>对应缓存的一次读取记录</li><li><code>REMOVE key</code> — 是<code>key</code>对应缓存的一次移除记录</li><li><code>CLEAN key length[]</code>— <code>CLEAN</code>表明对应磁盘缓存已经成功被生成，可供读取，<code>length[]</code>是同一 key 对应的不同分块的大小，当<code>CLEAN</code>记录生成时也就意味着磁盘缓存文件去掉了带后缀 <code>.tmp</code>的<code>DIRTY</code>状态</li><li><code>DIRTY key</code>— <code>DIRTY</code>是相对于上面的<code>CLEAN</code>而言的，当磁盘缓存处于正在编辑状态时(即调用<code>diskLruCache.edit()</code>时)便会生成<code>DIRTY</code>记录，一般来说每条<code>DIRTY</code>记录后面都会接上一条<code>CLEAN</code>(即成功调用<code>editor.commit()</code>)或<code>REMOVE</code>(即调用<code>editor.commit()</code>时出错)</li></ul><p>在缓存记录之外，Journal 文件在初始化创建的时候还有一些固定的头部信息，包括了文件名、版本号和<code>valueCount</code>(决定每一个 key 能匹配的 Entry 数量)。</p><p>当缓存记录超过2000条的时候，Journal 文件会根据 LinkedHashMap 进行重建。</p><p>接下来结合正常使用时的 API 来分析</p><h5 id="初始化缓存"><a href="#初始化缓存" class="headerlink" title="初始化缓存"></a>初始化缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>directory</code>缓存的路径</li><li><code>appVersion</code>版本号，用于给 Journal 文件判断缓存是否有效</li><li><code>valueCount</code>每个 key 对应 <code>Entry</code>的数量</li><li><code>maxSize</code>缓存的最大值，当超过时依照 LRU 策略移除超出的部分</li></ul><p><code>open()</code>方法会检查是否已经存在 Journal 文件，若存在就根据 Journal 文件初始化 LinkedHashMap，若不存在则新建一个。</p><h5 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h5><p>调用<code>edit()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache.Editor editor = mDiskCache.edit(key);</span><br></pre></td></tr></table></figure><p>正常情况会返回一个<code>Editor</code>对象给我们进行处理流，但当该 key 对应的 <code>Entry</code>正在被编辑也就是处于<code>DIRTY</code>状态时将返回一个空值，这时只有上一个<code>Editor</code>调用<code>commit()</code>或<code>abort()</code>方法后才会解除<code>DIRTY</code>状态。</p><p>通过调用<code>editor.newOutputStream(index)</code>可以获取输出流来将我们的缓存输出至磁盘。值得注意的是，我们获得的输出流其实写到的是后缀为<code>.tmp</code>的 dirty 文件里，只有当我们调用<code>editor.commit()</code>的时候才会把<code>.tmp</code>后缀去掉成为正式有效的缓存，调用<code>editor.abort()</code>方法是将 dirty 文件从磁盘删除掉。</p><h5 id="查询-读取缓存"><a href="#查询-读取缓存" class="headerlink" title="查询/读取缓存"></a>查询/读取缓存</h5><p>我们可以通过<code>Snapshot</code>对象去查询/读取缓存，调用<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache.Snapshot snapshot = mDiskCache.get(key);</span><br></pre></td></tr></table></figure><p>查询的话，只需要判断返回的<code>Snapshot</code>对象是否为空，直接调用<code>snapshot.close()</code>方法离开即可，<code>get(key)</code>这个方法里就已经实现了 LRU 策略的缓存更新。</p><p>读取缓存的话，我们可以通过调用 <code>snapshot.getInputStream(index)</code>去获取缓存的输入流，操作输入流即可获得缓存。</p><h5 id="关闭缓存"><a href="#关闭缓存" class="headerlink" title="关闭缓存"></a>关闭缓存</h5><p>直接调用<code>diskLruCache.close()</code>即可，<code>close()</code>方法会把 Journal 的 writer 关掉，也会把所有 dirty 文件删除掉。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.mindorks.com/this-post-is-about-the-implementation-details-of-jake-whartons-famous-disklrucache-9a87d90206fe" target="_blank" rel="noopener">A deep dive into Jake Wharton’s DiskLruCache</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试去简单分析来自 &lt;a href=&quot;https://github.com/JakeWharton&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jake Wharton&lt;/a&gt; 大神的 &lt;a href=&quot;https://github.com/JakeWharton/DiskLruCache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DiskLruCache&lt;/a&gt; 库，尽管这个库已经有多年历史，但至今仍然被 &lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OkHttp&lt;/a&gt;、&lt;a href=&quot;https://github.com/bumptech/glide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Glide&lt;/a&gt; 等主流基础库用以作为磁盘缓存的基础，仍有不错的学习价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>简单分析 ThreadLocal</title>
    <link href="https://nich.work/2017/ThreadLocal/"/>
    <id>https://nich.work/2017/ThreadLocal/</id>
    <published>2017-08-28T08:58:58.000Z</published>
    <updated>2017-08-28T09:22:35.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> ThreadLocal 可简单理解为 Thread 的局部变量，在线程的生命周期内起作用。</p></blockquote><a id="more"></a><h3 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h3><p>ThreadLocal 类的内部有 ThreadLocalMap内部类，Entry 又是 ThreadLocalMap 类里的内部类。</p><p>ThreadLocalMap 是一个为 ThreadLocal 提供服务的 “customized hash map” 。</p><p>Entry 是一个继承 WeakReference 的类，是 ThreadLocalMap 的构成类型，Entry 的中的 key 即为 ThreadLocal。</p><p>Thread 类里声明了 ThreadLocalMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. */</span></span><br><span class="line"><span class="comment">/* This map is maintained by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>接下来分析下 ThreadLocal 类的代码 (Android SDK 25) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取与当前线程绑定的 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 HashMap 里获取当前 ThreadLocal 的值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T) e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 当前线程没有 ThreadLocalMap 对象，初始化 ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用我们 Override 的方法来初始化，默认的 initialValue() 返回 null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外的 <code>set</code> 、<code>createMap</code> 、<code>getMap</code> 等的方法都是些常见 HashMap 的操作。</p><h3 id="ThreadLocal-使用不当造成的内存泄漏"><a href="#ThreadLocal-使用不当造成的内存泄漏" class="headerlink" title="ThreadLocal 使用不当造成的内存泄漏"></a>ThreadLocal 使用不当造成的内存泄漏</h3><p>因为 ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，所以当系统 GC ，ThreadLocal对象被回收，ThreadLocalMap 中就会有 key 为空的 Entry，这个 Entry 的 value 就没法访问了，要是线程由于种种原因没有结束的话（譬如作为线程池的一员），那么 key 为空的 Entry 中的 value 由于被强引用  <code>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</code> 导致没法被回收，造成内存泄漏。</p><p>那么需要怎么做来避免泄漏呢？</p><p>其实当调用 ThreadLocal 的 <code>get</code>、  <code>set</code>、 <code>remove</code> 的时候都会调用到 ThreadLocalMap 里的方法将 key 为空的 Entry 的 value 置空。</p><p>所以正确的做法是在用完 Threadlocal 后，都调用 <code>remove</code> 方法来清除数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; ThreadLocal 可简单理解为 Thread 的局部变量，在线程的生命周期内起作用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅析Android消息机制Handler</title>
    <link href="https://nich.work/2017/handler/"/>
    <id>https://nich.work/2017/handler/</id>
    <published>2017-07-27T15:20:03.000Z</published>
    <updated>2017-07-27T15:39:39.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试对Handler及其相关组件在Java层进行简单分析。</p><blockquote><p>最初学习Android开发时，经常会碰到使用Handler切换线程来更新UI的代码。而现在，大家似乎更喜欢用其它方式去实现多线程的切换。即便如此，作为Android Framework架构的一个基础控件，Handler机制依旧有其学习价值。</p></blockquote><a id="more"></a><p>Handler由以下部分组成：</p><ul><li><a href="https://developer.android.com/reference/android/os/Looper.html" target="_blank" rel="noopener">Looper</a></li><li><a href="https://developer.android.com/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a></li><li><a href="https://developer.android.com/reference/android/os/MessageQueue.html" target="_blank" rel="noopener">MessageQueue</a></li><li><a href="https://developer.android.com/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a></li></ul><p>它们之间的运作方式可以以可视化的方式展示为：</p><p><img src="Handler-Looper-Message-MessageQueue.png" width="480"></p><p>接下来会对各个组件进行分析。</p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper 是在线程内维持 Message 循环的一个类。</p><p>我们一般在主线程里声明 Handler，而有时我们需要在其它线程里声明 Handler，若与在主线程里一样直接声明的话会抛异常，原因是主线程(<code>ActivityThread</code>)已经调用了 Looper 的<code>prepareMainLooper()</code>和<code>loop()</code>方法。(实际开发中用HandlerThread即可，没有必要自己创建关联 Looper 的线程)</p><p>我们来分析 Looper 的两个主要方法<code>prepare()</code>和<code>loop()</code>：</p><ul><li><code>Looper.prepare()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，每个线程只能绑定一个Looper实例，<code>prepare()</code>方法通过<code>ThreadLocal</code>实现 Looper 实例与线程间的绑定，<br>通过观察 Looper 构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得知，在 Looper 实例化时会创建一个<code>MessageQueue</code>对象以及持有当前线程的引用。</p><ul><li><code>Looper.loop()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper 对象不能为空，也即<code>loop()</code>方法的调用必须放在<code>prepare()</code>方法后。</p><p><code>loop()</code>方法里，Looper 会不断地<code>MessageQueue.next()</code>方法从 MessageQueue 对象里的取出 Message，然后通过代码<code>msg.target.dispatchMessage(msg)</code>让 Message 所绑定的 Handler 执行<code>dispatchMessage()</code>方法来处理 Message。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler 可以在线程绑定的 MessageQueue 中传递和处理 Message。</p><p>Handler 有多个构造函数，篇幅所限，这里只分析默认构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法里获取了线程绑定的 Looper 实例，又通过该 Looper 实例获取了其中的 MessageQueue 实例。</p><blockquote><p>同一线程里的多个Handler实例分享同一个 MessageQueue 实例，因为他们分享同一个 Looper 实例。</p></blockquote><p>一般我们通过调用方法<code>sendMessage()</code>及其变式来把 Message 添加到 MessageQueue的末尾，据分析方法源码可知，无论是<code>sendMessage()</code>还是<code>post()</code>其最终调用的都是<code>Handler.enqueueMessage()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以得知上面 Looper 里的 <code>loop()</code>方法里代码<code>msg.target.dispatchMessage(msg)</code>中的 target 即是传递 Message 时绑定的 Handler 对象。</p><p>再来看看<code>dispatchMessage()</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Handler 有三种方式来处理 Message，依次为：</p><ol><li>由用<code>Handler.post()</code>方式传递 Runnable 包装成的 Message 里的 Runnable 自行处理。</li><li>由 Handler 构造函数传入的 Callback 处理。</li><li>由 Handler 的<code>handleMessage()</code>方法处理。</li></ol><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Message 是容纳任意数据的容器。</p><p>Message 一般通过调用<code>obtain()</code>或者<code>obtainMessage()</code>方法来获取实例，因为 Message 里维护了一个存储了 Message 对象最大值为50的 LinkedList 集合。</p><p>在 Looper 的<code>loop()</code>方法里，当 Handler 完成对 Message 的处理后，会调用<code>Message.recycleUnchecked()</code>方法来重置 Message。</p><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue 是一个将被 Looper 分发的 Message 链表集合。</p><p>上面 <a href="#Handler">Handler</a> 里提到的将 Message 添加到 MessageQueue 的 <code>Handler.enqueueMessage()</code>方法最终调用的是<code>MessageQueue.enqueueMessage()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以较为直观的层次(不涉及native层方法)来解释上面的逻辑：</p><ul><li>判断 Message 是否指定 Handler</li><li>判断 Message 是否已经插入到链表中<ul><li>判断 MessageQueue 是否在退出状态<ul><li>退出状态抛出异常，回收 Message</li><li>非退出状态<ul><li>把 Message 标记为已插入，为 Message 附上入参的时间戳</li><li>判断 Message 相对链表的位置<ul><li>置于链表头部</li><li>比较并置于链表相应位置里</li></ul></li></ul></li></ul></li></ul></li></ul><p>水平所限，MessageQueue 其它部分读不懂，故先分析到这里。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><blockquote><p>当直接在主线程里直接声明 Handler 时，IDE 的 Lint 提醒代码可能会造成内存泄漏。</p></blockquote><h5 id="泄漏的原因"><a href="#泄漏的原因" class="headerlink" title="泄漏的原因"></a>泄漏的原因</h5><p>所有使用 Handler 发送的 Message 都会调用到 <a href="#Handler"><code>Handler.enqueueMessage()</code></a>方法，正如上面分析的，在该方法里，Handler 的引用被显式地赋予了<code>msg.target</code>，用于 Looper 对应 MessageQueue 里的 Message 从 MessageQueue 出列时能选择相对应的 Handler 进行处理。</p><p>Message 添加到 MessageQueue 后，MessageQueue 就持有了 Message 的引用。而 MessageQueue 又被跟程序有相同生命时长的主线程 Looper 所引用。因此，Message 中持有的 Handler 会一直持续到 Message 被 MessageQueue 回收。</p><p>虽然 Handler 有很长的存活时间，但不能确定 Activity 是否发生了泄漏。要检查是否发生了泄漏，我们需要确定 Handler 是否在类里持有了 Activity 的引用。若 Handler 是以一个非静态内部类的形式声明于类中，那么便会发生泄漏，因为非静态内部类对其外部类持有一个隐式引用。    </p><h5 id="解决泄漏"><a href="#解决泄漏" class="headerlink" title="解决泄漏"></a>解决泄漏</h5><p>通过组合使用弱引用和静态修饰符可防止 Activity 内存泄漏。当 Activity 被销毁时，弱引用会让 GC 能回收你依旧持有的 Activity 引用。而在 Handler 内部类前添加静态修饰符可以避免持有外部类的隐式引用。</p><p>由于应用了弱引用，在使用 Actvity 引用时要格外小心，因为有可能已经被 GC 回收了，不妨先加个判断条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (activity == <span class="keyword">null</span> || activity.isFinishing() || activity.isDestroyed()) &#123;</span><br><span class="line">    <span class="comment">// 清空 callbacks 和 messages.</span></span><br><span class="line">    removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a" target="_blank" rel="noopener">Understanding Android Core: Looper, Handler, and HandlerThread (Janishar Ali)</a></li><li><a href="https://medium.com/@jagsaund/android-handler-internals-b5d49eba6977" target="_blank" rel="noopener">Android Handler Internals (Jag Saund)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试对Handler及其相关组件在Java层进行简单分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最初学习Android开发时，经常会碰到使用Handler切换线程来更新UI的代码。而现在，大家似乎更喜欢用其它方式去实现多线程的切换。即便如此，作为Android Framework架构的一个基础控件，Handler机制依旧有其学习价值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>WindowInsets and fitsSystemWindows</title>
    <link href="https://nich.work/2017/windowInsets&amp;fitsSystemWindows/"/>
    <id>https://nich.work/2017/windowInsets&amp;fitsSystemWindows/</id>
    <published>2017-06-24T08:03:03.000Z</published>
    <updated>2017-06-24T13:12:53.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>在翻看 ViewPager 源码的时候看到了这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(<span class="keyword">this</span>,</span><br><span class="line">    <span class="keyword">new</span> android.support.v4.view.OnApplyWindowInsetsListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> WindowInsetsCompat <span class="title">onApplyWindowInsets</span><span class="params">(<span class="keyword">final</span> View v,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> WindowInsetsCompat originalInsets)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ***</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>WindowInsets 是什么东西？为什么要监听？</p><p>本文尝试对 WindowInsets 作一个简单的了解。</p><h3 id="WindowInsets"><a href="#WindowInsets" class="headerlink" title="WindowInsets"></a>WindowInsets</h3><p>依照惯例，先从<a href="https://developer.android.com/reference/android/view/WindowInsets.html" target="_blank" rel="noopener">WindowInsets</a>的官方类介绍出发</p><blockquote><p>Describes a set of insets for window content.</p></blockquote><blockquote><p>WindowInsets are immutable and may be expanded to include more inset types in the future. To adjust insets, use one of the supplied clone methods to obtain a new WindowInsets instance with the adjusted properties. </p></blockquote><blockquote><p>Added in API level 20</p></blockquote><p>从类介绍可以明确</p><ol><li>WindowInsets 是 window content 的插入物。</li><li>WindowInsets 是不可更改的，更改的话需要 clone 生成一个更改过相应属性的 WindowInsets 实例。</li></ol><p>还是很抽象，通过查看类的方法描述后可得知 WindowInsets 又区分为3种(more in the future)：</p><ol><li>SystemWindowInsets，被状态栏(status bar)、导航栏(navigation bar)和输入框(IME)等部分或完全遮住的区域。</li><li>WindowDecorInsets，被framework提供的控件所部分或完全遮住的区域，包括了 action bars 、title bars 和 toolbars ，处于 pending 状态，不用管。</li><li>StableInsets，被系统UI元素部分活完全遮住的区域，不会跟随相应元素的显示状态改变而改变。</li></ol><p>到这里就可以对 WindowInsets 作个简单的定义：<strong>WindowInsets是插入到应用window的区域，以SystemWindowInsets为主。</strong></p><p>那么 WindowInsets 到底有什么用呢？</p><p>在描述 WindowInsets 的作用前，在这里需要先来说说大家经常会碰到的<code>android:fitsSystemWindows=&quot;true&quot;</code>这个API。</p><h3 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>谷歌在 Android 4.4(Kitkat) 引入了半透明状态栏(translucent status bar)这个概念，而<code>fitsSystemWindows</code>这个API就是根据  WindowInsets 进行相应的处理，如设置 padding。</p><p>通常，我们实现半透明状态栏需要两步</p><blockquote><ol><li>在style.xml里设置 <code>android:windowTranslucentStatus</code>属性为<code>true</code>。</li><li>在相应的布局文件里设置 <code>android:fitsSystemWindows</code>属性为<code>true</code>。</li></ol></blockquote><p>其中第一步是第二步的基础。</p><p>通过查看布局的 Hierarchy View 可以得知，在没有设置半透明状态栏属性时，ContentView 的父控件会被设置一个高度等同于状态栏高度的 paddingTop，这时候 fitsSystemWindows 属性并不会生效。</p><h3 id="WindowInsets-amp-fitsSystemWindows"><a href="#WindowInsets-amp-fitsSystemWindows" class="headerlink" title="WindowInsets &amp; fitsSystemWindows"></a>WindowInsets &amp; fitsSystemWindows</h3><p>我们在 Activity 里通过<code>setContentView()</code>方法构建 DecorView 实例并添加到当前Activity的 PhoneWindow 。在添加到 PhoneWindow 的过程中会调用到 DecorView 的<code>dispatchApplyWindowInsets</code>方法去处理由系统提供的 WindowInsets 对象，由于 DecorView 和 FrameLayout 都没有重写<code>dispatchApplyWindowInsets</code>方法，所以是直接调用了 ViewGroup 的<code>dispatchApplyWindowInsets</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">dispatchApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用View的dispatchApplyWindowInsets方法处理insets</span></span><br><span class="line">    insets = <span class="keyword">super</span>.dispatchApplyWindowInsets(insets);</span><br><span class="line">    <span class="comment">// 判断insets是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (!insets.isConsumed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// insets没有被消费的的话就依照顺序分发给子view</span></span><br><span class="line">            insets = getChildAt(i).dispatchApplyWindowInsets(insets);</span><br><span class="line">            <span class="comment">// 有子view消费insets，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (insets.isConsumed()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看 View 的<code>dispatchApplyWindowInsets</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">dispatchApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把PFLAG3_APPLYING_INSETS标记加入到mPrivateFlag3</span></span><br><span class="line">        mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;</span><br><span class="line">        <span class="comment">// 倘若View有注册OnApplyWindowInsetsListener监听就直接调用onApplyWindowInsets，</span></span><br><span class="line">        <span class="comment">// 否则执行onApplyWindowInsets方法</span></span><br><span class="line">        <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span> &amp;&amp; mListenerInfo.mOnApplyWindowInsetsListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(<span class="keyword">this</span>, insets);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> onApplyWindowInsets(insets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将PFLAG3_APPLYING_INSETS标记从mPrivateFlag3移除</span></span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_APPLYING_INSETS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DecorView 并没有设置<code>OnApplyWindowInsetsListener</code>监听，所以执行 DecorView 的<code>onApplyWindowInsets</code>方法，DecorView 的<code>onApplyWindowInsets</code>方法并没有完全消费 WindowInsets 对象（消费了 StableInsets 和 WindowDecorInsets ），而是进行了状态栏(status bar)和导航栏(navigation bar)的一些占位操作，具体细节就不展开了。</p><p>系统提供的 WindowInsets 里的 StableInsets 和 WindowDecorInsets 被 DecorView 消费掉了，剩下交给我们处理的是 SystemWindowInsets。</p><p>说了一大堆，似乎并 <strong>没有说到 WindowInsets 和 fitsSystemWindows 到底是怎么联系起来的。</strong></p><p>其实他们的联系就在 View 的<code>onApplyWindowInsets</code>方法，上面 DecorView 重写了该方法，在一般没有设置<code>OnApplyWindowInsetsListener</code>监听的 View 会执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_FITTING_SYSTEM_WINDOWS) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fitSystemWindows(insets.getSystemWindowInsets())) &#123;</span><br><span class="line">            <span class="keyword">return</span> insets.consumeSystemWindowInsets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fitSystemWindowsInt(insets.getSystemWindowInsets())) &#123;</span><br><span class="line">            <span class="keyword">return</span> insets.consumeSystemWindowInsets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的话是会进入到<code>fitSystemWindowsInt</code>方法，我们来看看<code>fitSystemWindowsInt</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fitSystemWindowsInt</span><span class="params">(Rect insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">boolean</span> res = computeFitSystemWindows(insets, localInsets);</span><br><span class="line">        mUserPaddingLeftInitial = localInsets.left;</span><br><span class="line">        mUserPaddingRightInitial = localInsets.right;</span><br><span class="line">        internalSetPadding(localInsets.left, localInsets.top,</span><br><span class="line">            localInsets.right, localInsets.bottom);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的<code>computeFitSystemWindows</code>方法计算 padding 以及决定是否消费 SystemWindowInsets，<code>internalSetPadding</code>方法负责设置 padding。</p><p>从 if 条件可以看出，在相应的布局文件里设置<code>android:fitsSystemWindows=&quot;true&quot;</code>才会执行方法内容。</p><blockquote><p>fitsSystemWindows是一个深度优先的 API，第一个消费 WindowInsets 的对象是关键。</p></blockquote><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>当父布局是 LinearLayout、 RelativeLayout 和 FrameLayout 等“非质感设计”布局时，在其子 View 重载<code>onApplyInsets</code>或设置  OnApplyWindowInsetsListener 获取并消费 WindowInsets 对象时会出现 WindowInsets 对象为空的情况，原因是“非质感设计”布局并没有重写<code>onApplyWindowInsets</code>方法，导致深度遍历终止在了“非质感设计”布局。</p><p>这时候只需 Override 一下<code>onApplyWindowInsets</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT_WATCH)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; childCount; ++index)</span><br><span class="line">        getChildAt(index).dispatchApplyWindowInsets(insets); </span><br><span class="line">        <span class="comment">// let children know about WindowInsets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>至此，对 WindowInsets 有了简单的认识。</p><p><a href="#Trigger">Trigger</a> 里的 OnApplyWindowInsetsListener 就是 ViewPager 用于消费 WindowInsets 的一个监听。</p><p>Thanks for reading. Have a nice day :-)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec" target="_blank" rel="noopener">Why would I want to fitsSystemWindows? (Ian Lake)</a></li><li><a href="https://medium.com/@azizbekian/windowinsets-24e241d4afb9" target="_blank" rel="noopener">WindowInsets?? (Andranik Azizbekian)</a></li><li><a href="https://developer.android.com/reference/android/view/WindowInsets.html" target="_blank" rel="noopener">WindowInsets Class Overview (Android Reference)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Trigger&quot;&gt;&lt;a href=&quot;#Trigger&quot; class=&quot;headerlink&quot; title=&quot;Trigger&quot;&gt;&lt;/a&gt;Trigger&lt;/h3&gt;&lt;p&gt;在翻看 ViewPager 源码的时候看到了这样一段代码&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="Android" scheme="https://nich.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Another Clawer Script</title>
    <link href="https://nich.work/2016/another-clawer-script/"/>
    <id>https://nich.work/2016/another-clawer-script/</id>
    <published>2016-03-13T12:40:27.000Z</published>
    <updated>2016-03-13T13:28:19.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript才是我的Mother Tongue！</p></blockquote><a id="more"></a><p>骗你的~</p><h3 id="Inspired-by-Thunder-vip"><a href="#Inspired-by-Thunder-vip" class="headerlink" title="Inspired by Thunder-vip"></a>Inspired by <a href="https://github.com/nswbmw/thunder-vip" target="_blank" rel="noopener">Thunder-vip</a></h3><p>看到别人写了个控制台全局命令来爬数据的Script觉得很酷，模仿着写了个<a href="https://github.com/nichbar/share-vip" target="_blank" rel="noopener">share-vip</a>，基于node.js</p><p>发现node制作控制台全局命令并不难，方法：</p><ol><li>在项目根目录创建bin文件夹，并在里面创建一个没有js后缀的js文件，以想达到的控制台命令来命名</li><li>在该js文件头添加一句<code>#!/usr/bin/env node</code> 来添加到node的环境命令里</li><li>然后这个js文件该实现什么逻辑就完全自己决定了</li><li>最重要的是安装的时候必须指定-g（全局）才能实现控制台全局命令</li></ol><p>脚本的主要逻辑是先用<a href="https://github.com/request/request" target="_blank" rel="noopener">request</a>来执行网络请求，然后<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a>来访问获取到的DOM，接着用<a href="https://zh.wikipedia.org/zh/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式</a>把需要的东西匹配出来，最后用到了<a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a>来着色命令行的输出。</p><p>噢对了，我还好好的复习了一番正则表达式…</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>说回这个脚本本身，用法很简单，在控制台执行<code>npm install share-vip -g</code>就可以安装这个包。（当然，前提是你的机器上面有node.js和npm，如果没有请到<a href="https://nodejs.org" target="_blank" rel="noopener">node官网</a>下载）</p><p>然后打开控制台输入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vip thunder</span><br><span class="line">vip iqiyi</span><br><span class="line">vip youku</span><br></pre></td></tr></table></figure></p><p>分别代表迅雷、爱奇艺和优酷，然后控制台就有从某分享网站上抓取回来的帐号和密码了~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript才是我的Mother Tongue！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://nich.work/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Top Chrome Extension</title>
    <link href="https://nich.work/2016/top-chrome-extension/"/>
    <id>https://nich.work/2016/top-chrome-extension/</id>
    <published>2016-02-23T08:03:03.000Z</published>
    <updated>2016-02-24T14:26:32.837Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>插件才是<a href="http://liulanmi.com/chrome" target="_blank" rel="noopener">Chrome</a>成为最好用浏览器的关键</p></blockquote><p>窃以为要是没有插件支持的话，Chrome不过也就是跟<a href="https://www.microsoft.com/zh-cn/windows/microsoft-edge" target="_blank" rel="noopener">Edge</a>一样是个简洁轻快的浏览器而已。<br>我就推荐各位一些我自认为是最好的插件。<br><a id="more"></a></p><h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a><a href="http://www.one-tab.com/" target="_blank" rel="noopener">OneTab</a></h3><p>平时总喜欢点开一大堆的标签页，然后到了要<code>下班</code>or<code>睡觉</code>的时候浏览器会还有很多舍不得关掉的页面。</p><ul><li>把它们关进收藏夹？ 或许猴年马月才会再点开收藏夹释放它们。</li><li>关掉？ 万一错过了什么怎么办！</li><li>添加到笔记？ 没了排版都不想看了…</li></ul><p>OneTab简直就是我的救星，只需轻轻一点就可以把所有标签页汇集起来，下次再打开浏览器就可以看到上一次汇集的东西，可以自由地选择到底怎么处理它们。</p><h3 id="Pocket"><a href="#Pocket" class="headerlink" title="Pocket"></a><a href="https://getpocket.com/a/" target="_blank" rel="noopener">Pocket</a></h3><p>稍后读工具，在网上发现好文章可以一键添加到Pocket然后在手机上阅读。</p><h3 id="RescueTime"><a href="#RescueTime" class="headerlink" title="RescueTime"></a><a href="https://www.rescuetime.com/" target="_blank" rel="noopener">RescueTime</a></h3><p>正如其名字RescueTime一样是拯救时间的小工具，通过统计你在什么网站停留，结合本地软件可以汇总你一天在的电脑上的花的时间。<br>既有增加罪恶感的功能又要督促自己集中注意力的功效，是不可或缺的利器。</p><h3 id="Push-To-Kindle"><a href="#Push-To-Kindle" class="headerlink" title="Push To Kindle"></a><a href="https://chrome.google.com/webstore/detail/push-to-kindle/pnaiinchjaonopoejhknmgjingcnaloc/reviews?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="noopener">Push To Kindle</a></h3><p>只需登记好你在亚马逊的个人邮件地址，在网上遇到喜欢的文章就可以一键制作成mobi格式推送到kindle上，睡前读一读还是挺不错的。</p><h3 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a><a href="https://lastpass.com/" target="_blank" rel="noopener">LastPass</a></h3><p>不涉及个人信息的帐号密码都交给LastPass来管理，一键生成的密码即使被盗取也不会关联影响到其它。从此只需记住一个LastPass密码就可以访问一大堆的网站，再也不用因为忘记密码而发邮件找回密码浪费时间了。</p><h3 id="一键管理所有扩展"><a href="#一键管理所有扩展" class="headerlink" title="一键管理所有扩展"></a><a href="https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95/niemebbfnfbjfojajlmnbiikmcpjkkja/reviews?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="noopener">一键管理所有扩展</a></h3><p>有选择地开启或关闭上面提到的Chrome插件来节省内存资源，极其方便好用。</p><h3 id="围脖是个好图床"><a href="#围脖是个好图床" class="headerlink" title="围脖是个好图床"></a><a href="http://weibotuchuang.sinaapp.com/" target="_blank" rel="noopener">围脖是个好图床</a></h3><p>有用到图床的自然知道这是什么…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;插件才是&lt;a href=&quot;http://liulanmi.com/chrome&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome&lt;/a&gt;成为最好用浏览器的关键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;窃以为要是没有插件支持的话，Chrome不过也就是跟&lt;a href=&quot;https://www.microsoft.com/zh-cn/windows/microsoft-edge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Edge&lt;/a&gt;一样是个简洁轻快的浏览器而已。&lt;br&gt;我就推荐各位一些我自认为是最好的插件。&lt;br&gt;
    
    </summary>
    
    
      <category term="Efficiency" scheme="https://nich.work/tags/Efficiency/"/>
    
  </entry>
  
</feed>
