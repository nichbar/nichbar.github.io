<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android 单元测试 · Nich's Blog</title><meta name="description" content="Android 单元测试 - Nich"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#4fc08d"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script>var host = "nich.work";
if ((host == window.location.host) && (window.location.protocol != "https:"))
   window.location.protocol = "https";</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.github.com/nichbar" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android 单元测试</h1><div class="post-info">Dec 20, 2017</div><div class="post-content"><p>本文是学习 Android 单元测试时的一些笔记。</p>
<a id="more"></a>
<h3 id="Android-单元测试"><a href="#Android-单元测试" class="headerlink" title="Android 单元测试"></a>Android 单元测试</h3><p>采用 MVVM 作为 APP 架构的一个好处是在一定程度上分层剥离了 Android 层的代码， 使得基于 JAVA 层的单元测试 (Unit Test) 成为可能。</p>
<p>下面来介绍一些构建单元测试用到的 Library。</p>
<h4 id="1-JUnit-4"><a href="#1-JUnit-4" class="headerlink" title="1. JUnit 4"></a>1. JUnit 4</h4><p>单元测试使用的框架是 JUnit 4， JUnit 4 提供了 Java 层的测试基础。</p>
<p>一个简单的 JUnit 4 示例：</p>
<p>在 test 目录创建一个 TempTest.java 文件</p>
<blockquote>
<p><code>@RunWith</code>注解用于指定使用 JUnit 作为运行框架，<code>@Before</code>标示在测试开始前的操作，<code>@Test</code>标示测试本体。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TempTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mPackage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPackage = <span class="string">"jp.co.nintendo.supermario"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(mPackage.contains(<span class="string">"nintendo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法中的 <code>assertTrue()</code>是JUnit 原生提供的断言方法，于文件中直接右键<code>Run &#39;TempTest&#39;</code>即可运行测试。</p>
<p>更多 JUnit 的介绍可见 <a href="https://www.jianshu.com/p/e43e56667d9d" target="_blank" rel="noopener">JUnit单元测试框架的使用</a></p>
<p>更多 JUnit 的使用示例可见 <a href="http://www.vogella.com/tutorials/JUnit/article.html" target="_blank" rel="noopener">Unit Testing with JUnit - Tutorial</a></p>
<h4 id="2-Mockito"><a href="#2-Mockito" class="headerlink" title="2. Mockito"></a>2. Mockito</h4><p>Mockito 是一个 JAVA 层的 Mocking 框架，通过 Mockito 可以生成一个模拟的桩对象，可供单元测试时替换真实对象以达到两个目的</p>
<ol>
<li>验证这个对象的方法的调用情况，如调用次数和参数内容等</li>
<li>指定这个对象对特定调用方法的行为，如返回的值和额外执行其它操作等</li>
</ol>
<p>Mockito 基于 JUnit 4 ，所以类的基本构造与 JUnit 4一样。</p>
<p>一个简单的 Mockito 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApiService mService;</span><br><span class="line">    <span class="keyword">private</span> UploadRepository mRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 mock(clazz) 方法来模拟一个桩对象作为参数提供给需要被构造的对象</span></span><br><span class="line">        mService = mock(ApiService.class);</span><br><span class="line">        mRepository = <span class="keyword">new</span> UploadRepository(mService);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">  	<span class="comment">// 测试上传图片成功后 LiveData 是否发出响应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUploadImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable&lt;String&gt; observable = Observable.just(<span class="string">"Upload Success!"</span>);</span><br><span class="line">        MutableLiveData&lt;String&gt; liveData = mock(MutableLiveData.class);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// mService 是 mock (模拟)出来的空对象，这里设置了当调用 ApiService 的 postUploadImages</span></span><br><span class="line">      	<span class="comment">// 方法时直接返回上面生成的 observable    PS: anyObject() 意为接受任何参数</span></span><br><span class="line">        when(mService.postUploadImages(anyObject())).thenReturn(observable);</span><br><span class="line">      </span><br><span class="line">        mRepository.setLiveImageResponse(liveData);</span><br><span class="line">        mRepository.uploadImage(<span class="keyword">new</span> File(<span class="string">"/nintendo/supermario.png"</span>));</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 校验 liveData 对象是否调用了1次 postValue（） 方法</span></span><br><span class="line">        verify(liveData, times(<span class="number">1</span>)).postValue(anyObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多 Mockito 的介绍可见 <a href="http://www.jianshu.com/p/b6e0cf81641b" target="_blank" rel="noopener">Mock以及Mockito的使用</a></p>
<p>更多 Mockito 的使用示例可见 <a href="https://static.javadoc.io/org.mockito/mockito-core/2.13.0/org/mockito/Mockito.html#verification" target="_blank" rel="noopener">Mockito examples</a> </p>
<h4 id="3-Dagger-2"><a href="#3-Dagger-2" class="headerlink" title="3. Dagger 2"></a>3. Dagger 2</h4><p>在实际应用中，使用 Mockito 来模拟对象很快就遇到了问题，当模拟对象不是以参数形式传入被测试对象而是在被测试对象内部自行生成的话，mock 出来的模拟对象就无能为力了，为了继续进行测试可能就需要在测试对象里设置 <code>setXXX()</code>方法来把模拟对象传递进去。</p>
<p>单独为单元测试而在原逻辑代码里新增<code>setXXX()</code>的方法并不优雅，其实除了创建<code>setXXX()</code>方法这种方式以外，还可以使用 Dagger 2 以注解的形式进行 <a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入(Dependency Injection)</a> 来构造对象。</p>
<p>使用 Dagger 2 除了代码优雅一点以外，还有以下优点</p>
<ul>
<li>减轻了代码维护的压力，修改依赖构造方法的时候只需要修改提供者，请求依赖方不需改动，而不使用 Dagger 2 的话则需要修改每个调用了这个构造方法的类</li>
<li>可以松开一点数据和逻辑间的耦合</li>
</ul>
<p>下面来介绍 Dagger 2 的一些常用的注解 API</p>
<ul>
<li><p><code>@Inject</code>： 标记需要被 Dagger2 注入的依赖，常用的有两种注解方式</p>
<ul>
<li><p>注解构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivityPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoginActivity loginActivity;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginActivityPresenter</span><span class="params">(LoginActivity loginActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loginActivity = loginActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Inject</code>注解构造器除了能从依赖图里获取参数依赖还能成为依赖图的一部分，即其亦可于在需要的时候被注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>@Inject</code>注解构造器的一个限制是在一个类中只能注解一个构造函数。</p>
</blockquote>
</li>
<li><p>注解变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Inject</code>注解变量这种依赖注入方式需要手动调用注入，要在类中的某个地方执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        getAppComponent().inject(<span class="keyword">this</span>);    <span class="comment">// 请求依赖注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>inject()</code>方法调用前，变量的值均为空。</p>
<blockquote>
<p> <em>注意，<code>@Inject</code>注解的变量的修饰符不能为 <code>private</code></em>，原因是 Dagger 2 自动生成的代码需要显式访问该变量(确切地说是为该变量赋值)，与 Butterknife 同理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>@Module</code>：用于标记提供依赖的类，Dagger 2 在此寻找依赖</p>
</li>
<li><p><code>@Provides</code>： 在含有<code>@Module</code>注解的类中使用，用于标记提供依赖的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiModule</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Provides</span> <span class="comment">// 让 Dagger 2 知道这个方法提供 OkHttpClient 依赖，方法名一般命名为 provideXXX()</span></span><br><span class="line">    <span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Component</code>： 用于构建提供依赖的接口，可以在这里定义需要获得的依赖来自于哪个被<code>@Module</code>修饰的类(或者其它被<code>@Components</code>修饰的类)。<code>@Component</code>可以理解为提供依赖的<code>@Module</code>与待注入依赖的<code>@Inject</code>间的桥梁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;ApiModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Scope</code>：用于自定义依赖单例的生命周期，更多细节可参考<a href="http://blog.csdn.net/mq2553299/article/details/73414710" target="_blank" rel="noopener">Scope注解的使用及源码分析</a></p>
</li>
<li><p><code>@Singleton</code>： 用于标记单例，若已存在实例不再生成直接返回</p>
</li>
<li><p><code>@Qualifier</code>： 用于区分相同类型的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiRetrofit &#123;&#125;</span><br><span class="line">------- <span class="comment">// Class divider</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserRetrofit &#123;&#125;</span><br><span class="line">------- <span class="comment">// Class divider</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@UserRetrofit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">provideUserRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(<span class="string">"User"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@ApiRetrofit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">provideApiRetrofit</span><span class="params">(OkHttpClient okHttpClient)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Retrofit(<span class="string">"Api"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiService <span class="title">provideApiService</span><span class="params">(@ApiRetrofit Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(ApiService.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">provideUserService</span><span class="params">(@UserRetrofit Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(UserService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单介绍了常用 API ，接下来演示简单的用法</p>
<p>首先是提供依赖类 <code>@Module</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiModule</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">LoginActivityPresenter <span class="title">provideLoginPresenter</span><span class="params">(OkhttpClient client)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">new</span> LoginActivityPresenter(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是桥梁 <code>@Component</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;ApiModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是需要被注入依赖的 <code>LoginActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    LoginActivityPresenter presenter;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">      	<span class="comment">// DaggerApiComponent 是由 Dagger2 实现 ApiComponent 接口自动生成的类</span></span><br><span class="line">        DaggerApiComponent.builder()</span><br><span class="line">                .build()</span><br><span class="line">                .inject(<span class="keyword">this</span>);</span><br><span class="line">      </span><br><span class="line">      	presenter.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 presenter 对象就由 Dagger 2 实现了注入，可供使用。</p>
<p>更多相关的 Dagger 2 使用技巧可见 <a href="https://github.com/xitu/gold-miner/blob/master/TODO/Dependency-Injection-with-Dagger-2.md" target="_blank" rel="noopener">用 Dagger 2 实现依赖注入</a></p>
<p>虽然 Dagger 2 自动生成代码完成依赖注入很棒，但因为 <code>Activity</code>和<code>Fragment</code>等控件是由安卓系统生成，导致许多成员注入都写在它们的生命周期回调里，许多类最后会变成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrombulationActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> Frombulator frombulator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// DO THIS FIRST. Otherwise frombulator might be null!</span></span><br><span class="line">        ((SomeApplicationBaseType) getContext().getApplicationContext())</span><br><span class="line">            .getApplicationComponent()</span><br><span class="line">            .newActivityComponentBuilder()</span><br><span class="line">            .activity(<span class="keyword">this</span>)</span><br><span class="line">            .build()</span><br><span class="line">            .inject(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// ... now you can write the exciting code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断地重复这样的代码会导致这样的问题：</p>
<ol>
<li>不利于重构，拷来拷去，可能到最后会忘了这段代码的实际用途</li>
<li>往更深一层去看，这些代码显式地去指明了它的注入者，即便指明的是接口但也违背了依赖注入时类本身不知道注入方式的基本原则</li>
</ol>
<p>这时候应用 <a href="https://google.github.io/dagger//android.html" target="_blank" rel="noopener">dagger.android</a> 库就可以使代码更优雅。</p>
<p>下面来介绍一下 dagger.android 这个库的简单使用方式</p>
<ol>
<li><p>在 Application 级的 Component 里添加 AndroidInjectionModule</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;AndroidInjectionModule.class, AppModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// For brevity.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为需要注入依赖的 Activity 书写继承了 AndroidInjector\<youractivity> 的接口，并带有继承了AndroidInjector\<youractivity> 一个抽象的 Builder类</youractivity></youractivity></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subcomponent 可以理解为子 Component，在拥有自己的 Mod概念概念ule 的同时亦可以使用父 Component 的</span></span><br><span class="line"><span class="comment">// Module，不同 Subcomponent 之间的 Module 不能直接互用 （类似于命名空间的概念）</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = ...)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">YourActivitySubcomponent</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>&lt;<span class="title">YourActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AndroidInjector</span>.<span class="title">Builder</span>&lt;<span class="title">YourActivity</span>&gt; </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化简化定义了上述 SubComponent 以后再写一个 Module 来绑定它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span>(subcomponents = YourActivitySubcomponent.class)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivityModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@IntoMap</span></span><br><span class="line">    <span class="meta">@ActivityKey</span>(YourActivity.class)</span><br><span class="line">    <span class="keyword">abstract</span> AndroidInjector.Factory&lt;? extends Activity&gt;</span><br><span class="line">        bindYourActivityInjectorFactory(YourActivitySubcomponent.Builder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 Application 级的 Component 里将 Module 添加进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;AndroidInjectionModule.class,, YourActivityModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// For brevity.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 SubComponent 及其 Builder 没有其它方法或者是超类的话，可以用 @ContributesAndroidInjector 注解来替换掉上面的步骤2和步骤3 ，具体如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span>(modules = &#123; <span class="comment">/* modules to install into the subcomponent */</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> YourActivity <span class="title">contributeYourActivityInjector</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其添加至 Application 级的 Component 即可</p>
</li>
<li><p>Application 实现 HasActivityInjector 接口以及 <code>@Inject</code>注入一个 DispatchingAndroidInjector\<activity> 供 <code>activityInjector()</code> 作为返回值</activity></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">HasActivityInjector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingActivityInjector;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">super</span>.onCreate();</span><br><span class="line">      	DaggerAppComponent.create()</span><br><span class="line">          	.inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AndroidInjector&lt;Activity&gt; <span class="title">activityInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> dispatchingActivityInjector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在 Activity 调用 <code>super.onCreate()</code>前调用<code>AndroidInjector.inject()</code>即可完成依赖注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    AndroidInjection.inject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述是注入依赖到 Activity 的流程，注入依赖到 Fragment 中的方式也类似，具体差异可参考官方文档 <a href="https://google.github.io/dagger//android.html#Injecting%20Fragment%20objects" target="_blank" rel="noopener">Injecting Fragment objects</a></p>
<p>通过查看 Dagger 自动生成的 <code>DaggerAppComponent.java</code>文件不难发现， dagger.android 库通过分析提供的注解把提供依赖的 Module 添加到 Map 里，当在需要注入的控件调用 <code>AndroidInjection.inject(this)</code>其逻辑就是从该 Map 或其子 Map 里去取控件相对应的 Module 来实现依赖注入。</p>
<p>参照 <a href="https://github.com/googlesamples/android-architecture-components/blob/178fe541643adb122d2a8925cf61a21950a4611c/GithubBrowserSample/app/src/main/java/com/android/example/github/di/AppInjector.java#L41" target="_blank" rel="noopener">Google Archtitecture Sample</a> 通过使用<code>registerActivityLifecycleCallbacks()</code>以及<code>registerFragmentLifecycleCallbacks()</code>在控件相应的生命周期回调里调用 <code>AndroidInjection.inject()</code>方法的话，代码能达到进一步的简化。</p>
<h4 id="4-Espresso"><a href="#4-Espresso" class="headerlink" title="4. Espresso"></a>4. Espresso</h4><p>Google 官方将 APP 测试分为三种，小型、中型和大型测试，其分配的比例分为70% 、20%和10%。</p>
<p>上面介绍的单元测试就是占比最大的 70% 测试，而 Espresso 则是构成 20% 和 10% 所使用的库。</p>
<p>与Mockito 不一样 Espresso 是一个 UI 测试框架，运行时需要用到 Android 的代码，所以需要编译运行，时间会长很多。</p>
<p>下面是一个简单的 Espresso 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class) <span class="comment">// 与JUnit 4的内容略有不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadDetailFragmentTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span> <span class="comment">// 使用一个空的Activity来承载Fragment</span></span><br><span class="line">    <span class="keyword">public</span> ActivityTestRule&lt;SingleFragmentActivity&gt; mActivityRule =</span><br><span class="line">            <span class="keyword">new</span> ActivityTestRule&lt;&gt;(SingleFragmentActivity.class, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UploadViewModel mViewModel;</span><br><span class="line">    <span class="keyword">private</span> ApiService mApiService;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData mMutableLiveData = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UploadDetailFragment fragment = <span class="keyword">new</span> UploadDetailFragment();</span><br><span class="line"></span><br><span class="line">        mViewModel = mock(UploadViewModel.class);</span><br><span class="line">        mApiService = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(Config.API_HOST)</span><br><span class="line">                .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build().create(ApiService.class);</span><br><span class="line">      </span><br><span class="line">        when(mViewModel.getLiveData()).thenReturn(mMutableLiveData);</span><br><span class="line"></span><br><span class="line">        fragment.setMApiService(mApiService);</span><br><span class="line">        fragment.setMFactory(<span class="keyword">new</span> ViewModelProviderFactory&lt;&gt;(mViewModel));</span><br><span class="line"></span><br><span class="line">        mActivityRule.getActivity().setFragment(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试图片上传成功与失败的文字显示状态</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadCover</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 检测view是否处于显示状态</span></span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .perform(ViewActions.scrollTo())</span><br><span class="line">                .check(matches(isDisplayed()));</span><br><span class="line"></span><br><span class="line">        UploadObservableDataWrapper successWrapper = <span class="keyword">new</span> UploadObservableDataWrapper();</span><br><span class="line">        successWrapper.isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        successWrapper.dataType = DataType.APP_COVER_URL;</span><br><span class="line">        successWrapper.url = <span class="string">"https://pic.google.com/"</span>;</span><br><span class="line">        mMutableLiveData.postValue(successWrapper);</span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .check(matches(not(isDisplayed())));</span><br><span class="line"></span><br><span class="line">        UploadObservableDataWrapper failedWrapper = <span class="keyword">new</span> UploadObservableDataWrapper();</span><br><span class="line">        failedWrapper.isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        failedWrapper.dataType = DataType.APP_COVER_URL;</span><br><span class="line">        failedWrapper.url = <span class="string">"https://pic.google.com/"</span>;</span><br><span class="line">        mMutableLiveData.postValue(failedWrapper);</span><br><span class="line">        onView(withId(R.id.tv_upload_detail_cover_select))</span><br><span class="line">                .check(matches(isDisplayed()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多 Espresso 的介绍可见 <a href="http://www.jianshu.com/p/c5da84eae63b" target="_blank" rel="noopener">UI测试(Espresso)</a></p>
<p>更多 Espresso 的使用示例可见 <a href="http://www.vogella.com/tutorials/AndroidTestingEspresso/article.html" target="_blank" rel="noopener">Espresso Tutorial</a> </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>上文所有可跳转链接以及下列文章</p>
<ul>
<li><a href="https://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/" target="_blank" rel="noopener">Dependency injection with Dagger 2</a></li>
<li><a href="https://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/" target="_blank" rel="noopener">DaggerAndroid原理解析</a></li>
<li><a href="https://google.github.io/dagger/users-guide" target="_blank" rel="noopener">Dagger 2 Users Guide</a></li>
<li><a href="https://developer.android.com/topic/libraries/testing-support-library/index.html" target="_blank" rel="noopener">测试支持库</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/use-gradle-plugin-to-generate-code/" class="prev">PREV</a><a href="/2017/TCP/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2019 <a href="https://nich.work">Nich</a>, blow through the ceiling.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103473739-1",'auto');ga('send','pageview');</script></body></html>