<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 几种常见的排序算法 · Nich's Blog</title><meta name="description" content="几种常见的排序算法 - Nich"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#4fc08d"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script>var host = "nich.work";
if ((host == window.location.host) && (window.location.protocol != "https:"))
   window.location.protocol = "https";</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.github.com/nichbar" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">几种常见的排序算法</h1><div class="post-info">Sep 21, 2017</div><div class="post-content"><p>整理复习了一下几种常见的排序算法，参考资料为<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a>。简单分析了它们的基本原理，没有涉及到复杂度的计算，仅仅以结果的形式记录，在每种排序算法的最后都提供了 JavaScript 的实现代码。</p>
<a id="more"></a>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h3><p>重复地走访要排序的序列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访序列的工作是重复地进行直到不再需要交换，序列排序完成。</p>
<p><img src="https://i.loli.net/2017/09/22/59c47cb45d6f8.gif" alt="Bubble Sort"></p>
<p>时间复杂度为O(n^2)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">this</span>[j + <span class="number">1</span>] = <span class="keyword">this</span>[j];</span><br><span class="line">                <span class="keyword">this</span>[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-插入排序-Insertion-Sort"><a href="#2-插入排序-Insertion-Sort" class="headerlink" title="2. 插入排序 (Insertion Sort)"></a>2. 插入排序 (Insertion Sort)</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。</p>
<p>具体细节如图：</p>
<p><img src="https://i.loli.net/2017/09/22/59c4c62c3831e.gif" alt="Insertion Sort"></p>
<p>时间复杂度为O(n^2)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            temp = <span class="keyword">this</span>[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">this</span>[j - <span class="number">1</span>] = <span class="keyword">this</span>[j];</span><br><span class="line">            <span class="keyword">this</span>[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-选择排序-Selection-Sort"><a href="#3-选择排序-Selection-Sort" class="headerlink" title="3. 选择排序 (Selection Sort)"></a>3. 选择排序 (Selection Sort)</h3><p>首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，放到已排序序列的末尾，循环此过程，直到所有元素排列完毕。</p>
<p>具体细节如图：</p>
<p><img src="https://i.loli.net/2017/09/22/59c4c7b9d3524.gif" alt="Selection-Sort-Animation.gif"></p>
<p>时间复杂度为O(n^2)。</p>
<p>交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, min;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = <span class="keyword">this</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="keyword">this</span>.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &lt; min) &#123;</span><br><span class="line">                min = <span class="keyword">this</span>[j];</span><br><span class="line">                <span class="keyword">this</span>[j] = <span class="keyword">this</span>[i];</span><br><span class="line">                <span class="keyword">this</span>[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-快速排序-Quick-Sort"><a href="#4-快速排序-Quick-Sort" class="headerlink" title="4. 快速排序(Quick Sort)"></a>4. 快速排序(Quick Sort)</h3><p>快速排序使用分治法，把一个序列分为两个子序列来排序。</p>
<p>步骤可分为：</p>
<ol>
<li>从序列中挑出一个元素作为基准(pivot)</li>
<li>重新排序序列，所有比基准值小的元素摆放在基准前面，比基准大的元素摆在基准后面</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子数列排序</li>
</ol>
<p><img src="https://i.loli.net/2017/09/22/59c47e6bc3dd5.gif" alt="Quick Sort"></p>
<p>最优时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)</p>
<p>基础版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">var</span> mid = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[i] &lt; mid[<span class="number">0</span>]) &#123;</span><br><span class="line">        	left.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	right.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left.quickSort().concat(mid.concat(right.quickSort()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>一样不好。额外需要的<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">内存</a>空间配置，在实际上的实现，也会极度影响速度和<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96" target="_blank" rel="noopener">缓存</a>的性能。有一个比较复杂使用<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a>（in-place）分区<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a>的版本，且在好的基准选择上，平均可以达到O(log <em>n</em>)空间的使用复杂度。(<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>)</p>
</blockquote>
<p>原地 (In-place) 版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.quickSortIP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = array[i];</span><br><span class="line">        array[i] = array[k];</span><br><span class="line">        array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> storeIndex = left;</span><br><span class="line">        <span class="keyword">var</span> pivot = array[right]; <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">                swap(array, i, storeIndex);</span><br><span class="line">                storeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(array, right, storeIndex); <span class="comment">// 将基准还原到正确位置</span></span><br><span class="line">        <span class="keyword">return</span> storeIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> storeIndex = partition(array, left, right);</span><br><span class="line">        sort(array, left, storeIndex - <span class="number">1</span>);</span><br><span class="line">        sort(array, storeIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-希尔排序-Shell-Sort"><a href="#5-希尔排序-Shell-Sort" class="headerlink" title="5. 希尔排序 (Shell Sort)"></a>5. 希尔排序 (Shell Sort)</h3><p>希尔排序是插入排序一种更高效的改进版本，基于以下插入排序的两种特点进行改进：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率</li>
<li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>算法思路：</p>
<ol>
<li>先取一个正整数 d1 (d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>取正整数 d2 (d2 &lt; d1)</li>
<li>重复上述操作，直到 di = 1 (i &gt;= 1)，即所有记录成为一个组，最后对这个组进行插入排序即可</li>
</ol>
<p>最优时间复杂度为O(<em>n</em> log2 <em>n</em>)，最坏时间复杂度为O(n^2)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处 d1 选取了 n/2</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = array[i];</span><br><span class="line">        array[i] = array[k];</span><br><span class="line">        array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt; <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>[j - gap] &gt; <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                    swap(<span class="keyword">this</span>, j - gap, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2017/TCP/" class="prev">PREV</a><a href="/2017/DiskLruCache/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2019 <a href="https://nich.work">Nich</a>, blow through the ceiling.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103473739-1",'auto');ga('send','pageview');</script></body></html>