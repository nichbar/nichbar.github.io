<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WindowInsets and fitsSystemWindows · Nich's Blog</title><meta name="description" content="WindowInsets and fitsSystemWindows - Nich"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#4fc08d"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script>var host = "nich.work";
if ((host == window.location.host) && (window.location.protocol != "https:"))
   window.location.protocol = "https";</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.github.com/nichbar" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">WindowInsets and fitsSystemWindows</h1><div class="post-info">Jun 24, 2017</div><div class="post-content"><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>在翻看 ViewPager 源码的时候看到了这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(<span class="keyword">this</span>,</span><br><span class="line">    <span class="keyword">new</span> android.support.v4.view.OnApplyWindowInsetsListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> WindowInsetsCompat <span class="title">onApplyWindowInsets</span><span class="params">(<span class="keyword">final</span> View v,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> WindowInsetsCompat originalInsets)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ***</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>WindowInsets 是什么东西？为什么要监听？</p>
<p>本文尝试对 WindowInsets 作一个简单的了解。</p>
<h3 id="WindowInsets"><a href="#WindowInsets" class="headerlink" title="WindowInsets"></a>WindowInsets</h3><p>依照惯例，先从<a href="https://developer.android.com/reference/android/view/WindowInsets.html" target="_blank" rel="noopener">WindowInsets</a>的官方类介绍出发</p>
<blockquote>
<p>Describes a set of insets for window content.</p>
</blockquote>
<blockquote>
<p>WindowInsets are immutable and may be expanded to include more inset types in the future. To adjust insets, use one of the supplied clone methods to obtain a new WindowInsets instance with the adjusted properties. </p>
</blockquote>
<blockquote>
<p>Added in API level 20</p>
</blockquote>
<p>从类介绍可以明确</p>
<ol>
<li>WindowInsets 是 window content 的插入物。</li>
<li>WindowInsets 是不可更改的，更改的话需要 clone 生成一个更改过相应属性的 WindowInsets 实例。</li>
</ol>
<p>还是很抽象，通过查看类的方法描述后可得知 WindowInsets 又区分为3种(more in the future)：</p>
<ol>
<li>SystemWindowInsets，被状态栏(status bar)、导航栏(navigation bar)和输入框(IME)等部分或完全遮住的区域。</li>
<li>WindowDecorInsets，被framework提供的控件所部分或完全遮住的区域，包括了 action bars 、title bars 和 toolbars ，处于 pending 状态，不用管。</li>
<li>StableInsets，被系统UI元素部分活完全遮住的区域，不会跟随相应元素的显示状态改变而改变。</li>
</ol>
<p>到这里就可以对 WindowInsets 作个简单的定义：<strong>WindowInsets是插入到应用window的区域，以SystemWindowInsets为主。</strong></p>
<p>那么 WindowInsets 到底有什么用呢？</p>
<p>在描述 WindowInsets 的作用前，在这里需要先来说说大家经常会碰到的<code>android:fitsSystemWindows=&quot;true&quot;</code>这个API。</p>
<h3 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>谷歌在 Android 4.4(Kitkat) 引入了半透明状态栏(translucent status bar)这个概念，而<code>fitsSystemWindows</code>这个API就是根据  WindowInsets 进行相应的处理，如设置 padding。</p>
<p>通常，我们实现半透明状态栏需要两步</p>
<blockquote>
<ol>
<li>在style.xml里设置 <code>android:windowTranslucentStatus</code>属性为<code>true</code>。</li>
<li>在相应的布局文件里设置 <code>android:fitsSystemWindows</code>属性为<code>true</code>。</li>
</ol>
</blockquote>
<p>其中第一步是第二步的基础。</p>
<p>通过查看布局的 Hierarchy View 可以得知，在没有设置半透明状态栏属性时，ContentView 的父控件会被设置一个高度等同于状态栏高度的 paddingTop，这时候 fitsSystemWindows 属性并不会生效。</p>
<h3 id="WindowInsets-amp-fitsSystemWindows"><a href="#WindowInsets-amp-fitsSystemWindows" class="headerlink" title="WindowInsets &amp; fitsSystemWindows"></a>WindowInsets &amp; fitsSystemWindows</h3><p>我们在 Activity 里通过<code>setContentView()</code>方法构建 DecorView 实例并添加到当前Activity的 PhoneWindow 。在添加到 PhoneWindow 的过程中会调用到 DecorView 的<code>dispatchApplyWindowInsets</code>方法去处理由系统提供的 WindowInsets 对象，由于 DecorView 和 FrameLayout 都没有重写<code>dispatchApplyWindowInsets</code>方法，所以是直接调用了 ViewGroup 的<code>dispatchApplyWindowInsets</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">dispatchApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用View的dispatchApplyWindowInsets方法处理insets</span></span><br><span class="line">    insets = <span class="keyword">super</span>.dispatchApplyWindowInsets(insets);</span><br><span class="line">    <span class="comment">// 判断insets是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (!insets.isConsumed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// insets没有被消费的的话就依照顺序分发给子view</span></span><br><span class="line">            insets = getChildAt(i).dispatchApplyWindowInsets(insets);</span><br><span class="line">            <span class="comment">// 有子view消费insets，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (insets.isConsumed()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 View 的<code>dispatchApplyWindowInsets</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">dispatchApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把PFLAG3_APPLYING_INSETS标记加入到mPrivateFlag3</span></span><br><span class="line">        mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;</span><br><span class="line">        <span class="comment">// 倘若View有注册OnApplyWindowInsetsListener监听就直接调用onApplyWindowInsets，</span></span><br><span class="line">        <span class="comment">// 否则执行onApplyWindowInsets方法</span></span><br><span class="line">        <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span> &amp;&amp; mListenerInfo.mOnApplyWindowInsetsListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(<span class="keyword">this</span>, insets);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> onApplyWindowInsets(insets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将PFLAG3_APPLYING_INSETS标记从mPrivateFlag3移除</span></span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_APPLYING_INSETS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView 并没有设置<code>OnApplyWindowInsetsListener</code>监听，所以执行 DecorView 的<code>onApplyWindowInsets</code>方法，DecorView 的<code>onApplyWindowInsets</code>方法并没有完全消费 WindowInsets 对象（消费了 StableInsets 和 WindowDecorInsets ），而是进行了状态栏(status bar)和导航栏(navigation bar)的一些占位操作，具体细节就不展开了。</p>
<p>系统提供的 WindowInsets 里的 StableInsets 和 WindowDecorInsets 被 DecorView 消费掉了，剩下交给我们处理的是 SystemWindowInsets。</p>
<p>说了一大堆，似乎并 <strong>没有说到 WindowInsets 和 fitsSystemWindows 到底是怎么联系起来的。</strong></p>
<p>其实他们的联系就在 View 的<code>onApplyWindowInsets</code>方法，上面 DecorView 重写了该方法，在一般没有设置<code>OnApplyWindowInsetsListener</code>监听的 View 会执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_FITTING_SYSTEM_WINDOWS) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fitSystemWindows(insets.getSystemWindowInsets())) &#123;</span><br><span class="line">            <span class="keyword">return</span> insets.consumeSystemWindowInsets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fitSystemWindowsInt(insets.getSystemWindowInsets())) &#123;</span><br><span class="line">            <span class="keyword">return</span> insets.consumeSystemWindowInsets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用的话是会进入到<code>fitSystemWindowsInt</code>方法，我们来看看<code>fitSystemWindowsInt</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fitSystemWindowsInt</span><span class="params">(Rect insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">boolean</span> res = computeFitSystemWindows(insets, localInsets);</span><br><span class="line">        mUserPaddingLeftInitial = localInsets.left;</span><br><span class="line">        mUserPaddingRightInitial = localInsets.right;</span><br><span class="line">        internalSetPadding(localInsets.left, localInsets.top,</span><br><span class="line">            localInsets.right, localInsets.bottom);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里的<code>computeFitSystemWindows</code>方法计算 padding 以及决定是否消费 SystemWindowInsets，<code>internalSetPadding</code>方法负责设置 padding。</p>
<p>从 if 条件可以看出，在相应的布局文件里设置<code>android:fitsSystemWindows=&quot;true&quot;</code>才会执行方法内容。</p>
<blockquote>
<p>fitsSystemWindows是一个深度优先的 API，第一个消费 WindowInsets 的对象是关键。</p>
</blockquote>
<h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>当父布局是 LinearLayout、 RelativeLayout 和 FrameLayout 等“非质感设计”布局时，在其子 View 重载<code>onApplyInsets</code>或设置  OnApplyWindowInsetsListener 获取并消费 WindowInsets 对象时会出现 WindowInsets 对象为空的情况，原因是“非质感设计”布局并没有重写<code>onApplyWindowInsets</code>方法，导致深度遍历终止在了“非质感设计”布局。</p>
<p>这时候只需 Override 一下<code>onApplyWindowInsets</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT_WATCH)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; childCount; ++index)</span><br><span class="line">        getChildAt(index).dispatchApplyWindowInsets(insets); </span><br><span class="line">        <span class="comment">// let children know about WindowInsets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>至此，对 WindowInsets 有了简单的认识。</p>
<p><a href="#Trigger">Trigger</a> 里的 OnApplyWindowInsetsListener 就是 ViewPager 用于消费 WindowInsets 的一个监听。</p>
<p>Thanks for reading. Have a nice day :-)</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec" target="_blank" rel="noopener">Why would I want to fitsSystemWindows? (Ian Lake)</a></li>
<li><a href="https://medium.com/@azizbekian/windowinsets-24e241d4afb9" target="_blank" rel="noopener">WindowInsets?? (Andranik Azizbekian)</a></li>
<li><a href="https://developer.android.com/reference/android/view/WindowInsets.html" target="_blank" rel="noopener">WindowInsets Class Overview (Android Reference)</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2017/handler/" class="prev">PREV</a><a href="/2016/another-clawer-script/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2019 <a href="https://nich.work">Nich</a>, blow through the ceiling.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103473739-1",'auto');ga('send','pageview');</script></body></html>