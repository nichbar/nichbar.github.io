<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅析Android消息机制Handler · Nich's Blog</title><meta name="description" content="浅析Android消息机制Handler - Nich"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#4fc08d"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script>var host = "nich.work";
if ((host == window.location.host) && (window.location.protocol != "https:"))
   window.location.protocol = "https";</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.github.com/nichbar" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅析Android消息机制Handler</h1><div class="post-info">Jul 27, 2017</div><div class="post-content"><p>本文尝试对Handler及其相关组件在Java层进行简单分析。</p>
<blockquote>
<p>最初学习Android开发时，经常会碰到使用Handler切换线程来更新UI的代码。而现在，大家似乎更喜欢用其它方式去实现多线程的切换。即便如此，作为Android Framework架构的一个基础控件，Handler机制依旧有其学习价值。</p>
</blockquote>
<a id="more"></a>
<p>Handler由以下部分组成：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/os/Looper.html" target="_blank" rel="noopener">Looper</a></li>
<li><a href="https://developer.android.com/reference/android/os/Message.html" target="_blank" rel="noopener">Message</a></li>
<li><a href="https://developer.android.com/reference/android/os/MessageQueue.html" target="_blank" rel="noopener">MessageQueue</a></li>
<li><a href="https://developer.android.com/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a></li>
</ul>
<p>它们之间的运作方式可以以可视化的方式展示为：</p>
<p><img src="Handler-Looper-Message-MessageQueue.png" width="480"></p>
<p>接下来会对各个组件进行分析。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper 是在线程内维持 Message 循环的一个类。</p>
<p>我们一般在主线程里声明 Handler，而有时我们需要在其它线程里声明 Handler，若与在主线程里一样直接声明的话会抛异常，原因是主线程(<code>ActivityThread</code>)已经调用了 Looper 的<code>prepareMainLooper()</code>和<code>loop()</code>方法。(实际开发中用HandlerThread即可，没有必要自己创建关联 Looper 的线程)</p>
<p>我们来分析 Looper 的两个主要方法<code>prepare()</code>和<code>loop()</code>：</p>
<ul>
<li><code>Looper.prepare()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，每个线程只能绑定一个Looper实例，<code>prepare()</code>方法通过<code>ThreadLocal</code>实现 Looper 实例与线程间的绑定，<br>通过观察 Looper 构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得知，在 Looper 实例化时会创建一个<code>MessageQueue</code>对象以及持有当前线程的引用。</p>
<ul>
<li><code>Looper.loop()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper 对象不能为空，也即<code>loop()</code>方法的调用必须放在<code>prepare()</code>方法后。</p>
<p><code>loop()</code>方法里，Looper 会不断地<code>MessageQueue.next()</code>方法从 MessageQueue 对象里的取出 Message，然后通过代码<code>msg.target.dispatchMessage(msg)</code>让 Message 所绑定的 Handler 执行<code>dispatchMessage()</code>方法来处理 Message。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler 可以在线程绑定的 MessageQueue 中传递和处理 Message。</p>
<p>Handler 有多个构造函数，篇幅所限，这里只分析默认构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法里获取了线程绑定的 Looper 实例，又通过该 Looper 实例获取了其中的 MessageQueue 实例。</p>
<blockquote>
<p>同一线程里的多个Handler实例分享同一个 MessageQueue 实例，因为他们分享同一个 Looper 实例。</p>
</blockquote>
<p>一般我们通过调用方法<code>sendMessage()</code>及其变式来把 Message 添加到 MessageQueue的末尾，据分析方法源码可知，无论是<code>sendMessage()</code>还是<code>post()</code>其最终调用的都是<code>Handler.enqueueMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以得知上面 Looper 里的 <code>loop()</code>方法里代码<code>msg.target.dispatchMessage(msg)</code>中的 target 即是传递 Message 时绑定的 Handler 对象。</p>
<p>再来看看<code>dispatchMessage()</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Handler 有三种方式来处理 Message，依次为：</p>
<ol>
<li>由用<code>Handler.post()</code>方式传递 Runnable 包装成的 Message 里的 Runnable 自行处理。</li>
<li>由 Handler 构造函数传入的 Callback 处理。</li>
<li>由 Handler 的<code>handleMessage()</code>方法处理。</li>
</ol>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Message 是容纳任意数据的容器。</p>
<p>Message 一般通过调用<code>obtain()</code>或者<code>obtainMessage()</code>方法来获取实例，因为 Message 里维护了一个存储了 Message 对象最大值为50的 LinkedList 集合。</p>
<p>在 Looper 的<code>loop()</code>方法里，当 Handler 完成对 Message 的处理后，会调用<code>Message.recycleUnchecked()</code>方法来重置 Message。</p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue 是一个将被 Looper 分发的 Message 链表集合。</p>
<p>上面 <a href="#Handler">Handler</a> 里提到的将 Message 添加到 MessageQueue 的 <code>Handler.enqueueMessage()</code>方法最终调用的是<code>MessageQueue.enqueueMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以较为直观的层次(不涉及native层方法)来解释上面的逻辑：</p>
<ul>
<li>判断 Message 是否指定 Handler</li>
<li>判断 Message 是否已经插入到链表中<ul>
<li>判断 MessageQueue 是否在退出状态<ul>
<li>退出状态抛出异常，回收 Message</li>
<li>非退出状态<ul>
<li>把 Message 标记为已插入，为 Message 附上入参的时间戳</li>
<li>判断 Message 相对链表的位置<ul>
<li>置于链表头部</li>
<li>比较并置于链表相应位置里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>水平所限，MessageQueue 其它部分读不懂，故先分析到这里。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><blockquote>
<p>当直接在主线程里直接声明 Handler 时，IDE 的 Lint 提醒代码可能会造成内存泄漏。</p>
</blockquote>
<h5 id="泄漏的原因"><a href="#泄漏的原因" class="headerlink" title="泄漏的原因"></a>泄漏的原因</h5><p>所有使用 Handler 发送的 Message 都会调用到 <a href="#Handler"><code>Handler.enqueueMessage()</code></a>方法，正如上面分析的，在该方法里，Handler 的引用被显式地赋予了<code>msg.target</code>，用于 Looper 对应 MessageQueue 里的 Message 从 MessageQueue 出列时能选择相对应的 Handler 进行处理。</p>
<p>Message 添加到 MessageQueue 后，MessageQueue 就持有了 Message 的引用。而 MessageQueue 又被跟程序有相同生命时长的主线程 Looper 所引用。因此，Message 中持有的 Handler 会一直持续到 Message 被 MessageQueue 回收。</p>
<p>虽然 Handler 有很长的存活时间，但不能确定 Activity 是否发生了泄漏。要检查是否发生了泄漏，我们需要确定 Handler 是否在类里持有了 Activity 的引用。若 Handler 是以一个非静态内部类的形式声明于类中，那么便会发生泄漏，因为非静态内部类对其外部类持有一个隐式引用。    </p>
<h5 id="解决泄漏"><a href="#解决泄漏" class="headerlink" title="解决泄漏"></a>解决泄漏</h5><p>通过组合使用弱引用和静态修饰符可防止 Activity 内存泄漏。当 Activity 被销毁时，弱引用会让 GC 能回收你依旧持有的 Activity 引用。而在 Handler 内部类前添加静态修饰符可以避免持有外部类的隐式引用。</p>
<p>由于应用了弱引用，在使用 Actvity 引用时要格外小心，因为有可能已经被 GC 回收了，不妨先加个判断条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (activity == <span class="keyword">null</span> || activity.isFinishing() || activity.isDestroyed()) &#123;</span><br><span class="line">    <span class="comment">// 清空 callbacks 和 messages.</span></span><br><span class="line">    removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a" target="_blank" rel="noopener">Understanding Android Core: Looper, Handler, and HandlerThread (Janishar Ali)</a></li>
<li><a href="https://medium.com/@jagsaund/android-handler-internals-b5d49eba6977" target="_blank" rel="noopener">Android Handler Internals (Jag Saund)</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2017/ThreadLocal/" class="prev">PREV</a><a href="/2017/windowInsets&amp;fitsSystemWindows/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2019 <a href="https://nich.work">Nich</a>, blow through the ceiling.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103473739-1",'auto');ga('send','pageview');</script></body></html>